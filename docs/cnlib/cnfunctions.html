<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>CNLib.cnlib.cnfunctions API documentation</title>
<meta name="description" content="A collection of common functions used by CN software â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em;margin-right:.5em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CNLib.cnlib.cnfunctions</code></h1>
</header>
<section id="section-intro">
<p>A collection of common functions used by CN software</p>
<h2 id="functions">Functions</h2>
<p>pascal_case: Convert a class name to it's Pascal equivalent
do_bool: Convert other values, like integers or strings, to bools
dpretty: Pretty print a dict
lpretty: Pretty print a list
pp: Pretty print a dictionary or list
combine_dicts: Update a dictionary with one or more dictionaries
sh: Run a command string in the shell
load_dicts: Combines dictionaries from all found paths
save_dict: Save a dictionary to all paths</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="CNLib.cnlib.cnfunctions.combine_dicts"><code class="name flex">
<span>def <span class="ident">combine_dicts</span></span>(<span>dicts_new, dict_old=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_dicts(dicts_new, dict_old=None):
    &#34;&#34;&#34;
    Update a dictionary with entries from another dict

    Args:
        dicts_new: A dictionary or list of dictionaries containing new
        keys/values to be updated in the old dictionary
        dict_old: The dictionary defined as the one to receive updates

    Returns:
        The updated dict_old, filled with updates from dict_new

    This function takes key/value pairs from each of the new dicts and
    adds/overwrites these keys and values in dict_old, preserving any values
    that are blank or None in dict_new. It is also recursive, so a dict or list
    as a value will be handled correctly.
    &#34;&#34;&#34;

    # default return val
    if dict_old is None:
        dict_old = {}

    # sanity check
    if isinstance(dicts_new, dict):
        dicts_new = [dicts_new]
    if len(dicts_new) == 0:
        return dict_old
    if not dict_old:
        dict_old = {}

    # go through the new dicts in order
    for dict_new in dicts_new:

        # for each k,v pair in dict_n
        for k, v in dict_new.items():
            # copy whole value if key is missing
            if not k in dict_old:
                dict_old[k] = v

            # if the key is present in both
            else:
                # if the value is a dict
                if isinstance(v, dict):
                    # start recursing
                    # recurse using the current key and value
                    dict_old[k] = combine_dicts([v], dict_old[k])

                # if the value is a list
                elif isinstance(v, list):
                    list_old = dict_old[k]
                    for list_item in v:
                        list_old.append(list_item)

                # if the value is not a dict or a list
                else:
                    # just copy value from one dict to the other
                    dict_old[k] = v

    # return the updated dict_old
    return dict_old</code></pre>
</details>
<div class="desc"><p>Update a dictionary with entries from another dict</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dicts_new</code></strong></dt>
<dd>A dictionary or list of dictionaries containing new</dd>
<dt>keys/values to be updated in the old dictionary</dt>
<dt><strong><code>dict_old</code></strong></dt>
<dd>The dictionary defined as the one to receive updates</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated dict_old, filled with updates from dict_new
This function takes key/value pairs from each of the new dicts and
adds/overwrites these keys and values in dict_old, preserving any values
that are blank or None in dict_new. It is also recursive, so a dict or list
as a value will be handled correctly.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.compare_versions"><code class="name flex">
<span>def <span class="ident">compare_versions</span></span>(<span>ver_old, ver_new)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_versions(ver_old, ver_new):
    &#34;&#34;&#34;
    Compare two version strings for relativity

    Args:
        ver_old: Old version string
        ver_new: New version string

    Returns:
        An integer representing the relativity of the two version strings.
        S_VER_SAME means the two versions are equal,
        S_VER_NEWER means new_ver is newer than old_ver (or there is no old_ver), and
        S_VER_OLDER means new_ver is older than old_ver.

    This method compares two version strings and determines which is older,
    which is newer, or if they are equal. Note that this method converts
    only the first three parts of a semantic version string
    (https://semver.org/).
    &#34;&#34;&#34;

    # test for new install (don&#39;t try to regex)
    if not ver_old or ver_old == &#34;&#34;:
        return S_VER_NEWER

    # test for equal (just save some cpu cycles)
    if ver_old == ver_new:
        return S_VER_SAME

    # compare version string parts (only x.x.x)
    res_old = re.search(R_VERSION, ver_old)
    res_new = re.search(R_VERSION, ver_new)

    # if both version strings are valid
    if res_old and res_new:

        # make a list of groups to check
        lst_groups = [
            R_VERSION_GROUP_MAJ,
            R_VERSION_GROUP_MIN,
            R_VERSION_GROUP_REV,
        ]

        # for each part as int
        for group in lst_groups:
            old_val = int(res_old.group(group))
            new_val = int(res_new.group(group))

            # slide out at the first difference
            if old_val &lt; new_val:
                return S_VER_NEWER
            elif old_val &gt; new_val:
                return S_VER_OLDER
            # parts are equal, go to the next one
            else:
                continue
    else:
        raise OSError(S_ERR_VERSION)

    # return same if all parts equal
    return S_VER_SAME</code></pre>
</details>
<div class="desc"><p>Compare two version strings for relativity</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ver_old</code></strong></dt>
<dd>Old version string</dd>
<dt><strong><code>ver_new</code></strong></dt>
<dd>New version string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An integer representing the relativity of the two version strings.
S_VER_SAME means the two versions are equal,
S_VER_NEWER means new_ver is newer than old_ver (or there is no old_ver), and
S_VER_OLDER means new_ver is older than old_ver.
This method compares two version strings and determines which is older,
which is newer, or if they are equal. Note that this method converts
only the first three parts of a semantic version string
(<a href="https://semver.org/">https://semver.org/</a>).</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.dialog"><code class="name flex">
<span>def <span class="ident">dialog</span></span>(<span>message, buttons, default='', btn_sep='/', msg_fmt='{} [{}]: ')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dialog(message, buttons, default=&#34;&#34;, btn_sep=&#34;/&#34;, msg_fmt=&#34;{} [{}]: &#34;):
    &#34;&#34;&#34;
    Create a dialog-like question and return the result
    
    Args:
        message: The message to display
        buttons: List of single char answers to the question
        default: The button item to return when the user presses Enter at the 
            question (default: &#34;&#34;)
        btn_sep: Char to use to separate button items
        msg_fmt: Format string to present message/buttons to the user

    Returns:
        A lowercased string that matches a button (or an empty string if the \
            entered option is not in the button list)

    This method returns the string entered on the command line in response to a
    question. If the entered option does not match any of the buttons, a blank
    string is returned. If you set a default and the option entered is just the
    Return key, the default string will be returned. If no default is present,
    the entered string must match one of the buttons array values. All returned
    values are lowercased. The question will be repeatedly printed to the 
    screen until a valid entry is made.

    Note that if default == &#34;&#34;, pressing Enter is not considered a valid entry.
    &#34;&#34;&#34;

    # make all params lowercase
    buttons = [item.lower() for item in buttons]
    default = default.lower()

    # --------------------------------------------------------------------------

    # if we passes a default
    if default != &#34;&#34;:

        # find the default
        if not default in buttons:

            # not found, add at end of buttons
            buttons.append(default)

        # upper case it
        buttons[buttons.index(default)] = default.upper()

    # --------------------------------------------------------------------------

    # add buttons to message
    btns_all = btn_sep.join(buttons)
    str_fmt = msg_fmt.format(message, btns_all)

    # lower everything again for compare
    buttons = [item.lower() for item in buttons]

    # --------------------------------------------------------------------------

    while True:

        # ask the question, get the result
        inp = input(str_fmt)
        inp = inp.lower()

        # # no input (empty)
        if inp == &#34;&#34; and default != &#34;&#34;:
            return default

        # input a button
        if inp in buttons:
            return inp</code></pre>
</details>
<div class="desc"><p>Create a dialog-like question and return the result</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message to display</dd>
<dt><strong><code>buttons</code></strong></dt>
<dd>List of single char answers to the question</dd>
<dt><strong><code>default</code></strong></dt>
<dd>The button item to return when the user presses Enter at the
question (default: "")</dd>
<dt><strong><code>btn_sep</code></strong></dt>
<dd>Char to use to separate button items</dd>
<dt><strong><code>msg_fmt</code></strong></dt>
<dd>Format string to present message/buttons to the user</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A lowercased string that matches a button (or an empty string if the
entered option is not in the button list)
This method returns the string entered on the command line in response to a
question. If the entered option does not match any of the buttons, a blank
string is returned. If you set a default and the option entered is just the
Return key, the default string will be returned. If no default is present,
the entered string must match one of the buttons array values. All returned
values are lowercased. The question will be repeatedly printed to the
screen until a valid entry is made.</p>
<p>Note that if default == "", pressing Enter is not considered a valid entry.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.do_bool"><code class="name flex">
<span>def <span class="ident">do_bool</span></span>(<span>val)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_bool(val):
    &#34;&#34;&#34;
    Convert other values, like integers or strings, to bools

    Args:
        val: The value to convert to a bool

    Returns:
        A boolean value converted from the argument

    Converts integers and strings to boolean values based on the rules.
    &#34;&#34;&#34;

    # lower all test vals
    rules_true = [item.lower() for item in L_RULES_TRUE]

    # return result
    return str(val).lower() in rules_true</code></pre>
</details>
<div class="desc"><p>Convert other values, like integers or strings, to bools</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>val</code></strong></dt>
<dd>The value to convert to a bool</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A boolean value converted from the argument
Converts integers and strings to boolean values based on the rules.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.dpretty"><code class="name flex">
<span>def <span class="ident">dpretty</span></span>(<span>dict_print, indent_size=4, indent_level=0, label=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dpretty(dict_print, indent_size=4, indent_level=0, label=None):
    &#34;&#34;&#34;
    Pretty print a dict

    Args:
        dict_print: The dictionary to print
        indent_size: The number of spaces to use for each indent level
        (default: 4)
        indent_level: The number of indent levels to use for this part of the
        print process (default: 0)
        label: The string to use as a label (default: None)

    Returns:
        The formatted string to print

    Raises:
        OSError if the first param is not a dict

    Formats a dictionary nicely so it can be printed to the console.
    &#34;&#34;&#34;

    # sanity check
    if not isinstance(dict_print, dict):
        raise OSError(S_ERR_NOT_DICT)

    # default out
    out = &#34;&#34;

    # print label
    if label is not None:
        out += label + &#34;: &#34;

    # convert indent_size to string and multiply by indent_level
    indent_str = (&#34; &#34; * indent_size) * (indent_level)

    # items will need an extra indent, since they don&#39;t recurse
    indent_str_next = (&#34; &#34; * indent_size) * (indent_level + 1)

    # default result opening brace (no indent in case it is nested and is
    # preceded by a key)
    out += indent_str + &#34;{\n&#34;

    # for each entry
    for k, v in dict_print.items():

        # print the key
        out += indent_str_next + f&#39;&#34;{k}&#34;: &#39;

        # if the value is a list
        if isinstance(v, list):

            # recurse the value and increase indent level
            ret = (
                lpretty(
                    v,
                    indent_size=indent_size,
                    indent_level=indent_level + 1,
                    label=None,
                )
                + &#34;\n&#34;
            )
            ret = ret.lstrip()
            out += ret

        # if the value is a dict
        elif isinstance(v, dict):

            # recurse the value and increase indent level
            ret = (
                dpretty(
                    v,
                    indent_size=indent_size,
                    indent_level=indent_level + 1,
                    label=None,
                )
                + &#34;\n&#34;
            )
            ret = ret.lstrip()
            out += ret

        # if it is a single entry (str, int, bool)
        else:

            # print the value, quoting it if it is a string
            if isinstance(v, str):
                out += f&#39;&#34;{v}&#34;,\n&#39;
            else:
                out += f&#34;{v},\n&#34;

    # get original indent
    indent_str = (&#34; &#34; * indent_size) * indent_level

    # # add closing bracket
    out += indent_str + &#34;}&#34;

    # return result
    return out</code></pre>
</details>
<div class="desc"><p>Pretty print a dict</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dict_print</code></strong></dt>
<dd>The dictionary to print</dd>
<dt><strong><code>indent_size</code></strong></dt>
<dd>The number of spaces to use for each indent level</dd>
<dt>(default: 4)</dt>
<dt><strong><code>indent_level</code></strong></dt>
<dd>The number of indent levels to use for this part of the</dd>
<dt>print process (default: 0)</dt>
<dt><strong><code>label</code></strong></dt>
<dd>The string to use as a label (default: None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The formatted string to print</p>
<h2 id="raises">Raises</h2>
<p>OSError if the first param is not a dict
Formats a dictionary nicely so it can be printed to the console.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.fix_globs"><code class="name flex">
<span>def <span class="ident">fix_globs</span></span>(<span>dir_start, dict_in)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_globs(dir_start, dict_in):
    &#34;&#34;&#34;
    Convert items in blacklist to absolute Path objects

    Args:
        dict_in: the dictionary with glob strings

    Returns:
        A dictionary of Path objects representing the globs

    Get absolute paths for all entries in the blacklist.
    &#34;&#34;&#34;

    # the un-globbed dict to return
    result = {}
    dir_start = Path(dir_start)

    # make a copy and remove path separators in one shot
    # NB: this is mostly for glob support, as globs cannot end in path
    # separators
    for key, val in dict_in.items():
        dict_in[key] = [item.rstrip(&#34;/&#34;) for item in val]

    # support for absolute/relative/glob
    # NB: adapted from cntree.py

    # for each section of blacklist
    for key, val in dict_in.items():

        # convert all items in list to Path objects
        paths = [Path(item) for item in val]

        # move absolute paths to one list
        abs_paths = [item for item in paths if item.is_absolute()]

        # move relative/glob paths to another list
        other_paths = [item for item in paths if not item.is_absolute()]

        # convert relative/glob paths back to strings
        other_strings = [str(item) for item in other_paths]

        # get glob results as generators
        glob_results = [dir_start.glob(item) for item in other_strings]

        # start with absolutes
        new_val = abs_paths

        # for each generator
        for item in glob_results:
            # add results as whole shebang
            new_val += list(item)

        # set the list as the result list
        result[key] = new_val

    # return the un-globbed dict
    return result</code></pre>
</details>
<div class="desc"><p>Convert items in blacklist to absolute Path objects</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dict_in</code></strong></dt>
<dd>the dictionary with glob strings</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary of Path objects representing the globs
Get absolute paths for all entries in the blacklist.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.get_dict_from_file"><code class="name flex">
<span>def <span class="ident">get_dict_from_file</span></span>(<span>path_cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dict_from_file(path_cfg):
    &#34;&#34;&#34;
    Open a json file and return the dict inside

    Args:
        path_cfg: Path to the file containing the dict

    Returns:
        The dict contained in the file

    Opens the specified file and returns the config dict found in it.
    &#34;&#34;&#34;

    # set conf dict
    try:
        with open(path_cfg, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as a_file:
            return json.load(a_file)

    # file not found
    except FileNotFoundError as e:
        raise OSError(S_ERR_NOT_FOUND.format(path_cfg)) from e

    # not valid json in file
    except json.JSONDecodeError as e:
        raise OSError(S_ERR_NOT_JSON.format(path_cfg)) from e</code></pre>
</details>
<div class="desc"><p>Open a json file and return the dict inside</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_cfg</code></strong></dt>
<dd>Path to the file containing the dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The dict contained in the file
Opens the specified file and returns the config dict found in it.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.load_dicts"><code class="name flex">
<span>def <span class="ident">load_dicts</span></span>(<span>paths, start_dict=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dicts(paths, start_dict=None):
    &#34;&#34;&#34;
    Combines dictionaries from all found paths

    Args:
        paths: The file path or list of file paths to load
        start_dict: The starting dict and final dict after combining (default:
        None)

    Returns:
        The final combined dictionary

    Raises:
        FileNotFoundError: If the file does not exist
        json.JSONDecodeError: If the file is not a valid JSON file

    Load the dictionaries from all files and use combine_dicts to combine them.
    &#34;&#34;&#34;

    # sanity check
    if isinstance(paths, (str, Path)):
        paths = [paths]

    # set the default result
    if start_dict is None:
        start_dict = {}

    # loop through possible files
    for path in paths:

        # sanity check
        path = Path(path).resolve()

        # sanity check
        if path is None or not path.exists():
            print(S_ERR_NOT_EXIST.format(path))
            continue

        # try each option
        try:

            # open the file
            with open(path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as a_file:
                # load dict from file
                new_dict = json.load(a_file)

                # combine new dict with previous
                start_dict = combine_dicts([new_dict], start_dict)

        # file not JSON
        except json.JSONDecodeError as e:
            raise OSError(S_ERR_NOT_VALID.format(path)) from e

    # return the final dict
    return start_dict</code></pre>
</details>
<div class="desc"><p>Combines dictionaries from all found paths</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong></dt>
<dd>The file path or list of file paths to load</dd>
<dt><strong><code>start_dict</code></strong></dt>
<dd>The starting dict and final dict after combining (default:</dd>
</dl>
<p>None)</p>
<h2 id="returns">Returns</h2>
<p>The final combined dictionary</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the file does not exist</dd>
<dt><code>json.JSONDecodeError</code></dt>
<dd>If the file is not a valid JSON file</dd>
</dl>
<p>Load the dictionaries from all files and use combine_dicts to combine them.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.lpretty"><code class="name flex">
<span>def <span class="ident">lpretty</span></span>(<span>list_print, indent_size=4, indent_level=0, label=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lpretty(list_print, indent_size=4, indent_level=0, label=None):
    &#34;&#34;&#34;
    Pretty print a list

    Args:
        list_print: The list to print
        indent_size: The number of spaces to use for each indent level
        (default: 4)
        indent_level: The number of indent levels to use for this part of the
        print process (default: 0)
        label: The string to use as a label (default: None)

    Returns:
        The formatted string to print

    Raises:
        OSError if the first param is not a list

    Formats a list nicely so it can be printed to the console.
    &#34;&#34;&#34;

    # sanity check
    if not isinstance(list_print, list):
        raise OSError(S_ERR_NOT_LIST)

    # default out
    out = &#34;&#34;

    # print label
    if label is not None:
        out += label + &#34;: &#34;

    # convert indent_size to string and multiply by indent_level
    indent_str = (&#34; &#34; * indent_size) * (indent_level)

    # items will need an extra indent, since they don&#39;t recurse
    indent_str_next = (&#34; &#34; * indent_size) * (indent_level + 1)

    # default result opening brace (no indent in case it is nested and is
    # preceded by a key)
    out += indent_str + &#34;[\n&#34;

    # for each entry
    for v in list_print:

        # if the value is a list
        if isinstance(v, list):

            # recurse the value and increase indent level
            ret = (
                lpretty(
                    v,
                    indent_size=indent_size,
                    indent_level=indent_level + 1,
                    label=None,
                )
                + &#34;\n&#34;
            )
            out += ret

        # if the value is a dict
        elif isinstance(v, dict):

            # recurse the value and increase indent level
            ret = (
                dpretty(
                    v,
                    indent_size=indent_size,
                    indent_level=indent_level + 1,
                    label=None,
                )
                + &#34;\n&#34;
            )
            out += ret

        # if it is a single entry (str, int, bool)
        else:

            # print the value, quoting it if it is a string
            if isinstance(v, str):
                out += indent_str_next + f&#39;&#34;{v}&#34;,\n&#39;
            else:
                out += indent_str_next + f&#34;{v},\n&#34;

    # get original indent
    indent_str = (&#34; &#34; * indent_size) * indent_level

    # # add closing bracket
    out += indent_str + &#34;]&#34;

    # return result
    return out</code></pre>
</details>
<div class="desc"><p>Pretty print a list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_print</code></strong></dt>
<dd>The list to print</dd>
<dt><strong><code>indent_size</code></strong></dt>
<dd>The number of spaces to use for each indent level</dd>
<dt>(default: 4)</dt>
<dt><strong><code>indent_level</code></strong></dt>
<dd>The number of indent levels to use for this part of the</dd>
<dt>print process (default: 0)</dt>
<dt><strong><code>label</code></strong></dt>
<dd>The string to use as a label (default: None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The formatted string to print</p>
<h2 id="raises">Raises</h2>
<p>OSError if the first param is not a list
Formats a list nicely so it can be printed to the console.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.pascal_case"><code class="name flex">
<span>def <span class="ident">pascal_case</span></span>(<span>a_str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pascal_case(a_str):
    &#34;&#34;&#34;
    Format a string in Pascal case

    Args:
        a_str: A string to convert to Pascal case

    Returns;
        The Pascal cased string

    Formats the given string to a Pascal case equivalent, ie. &#34;my_class&#34;
    becomes &#34;MyClass&#34;.
    &#34;&#34;&#34;

    # do formatting
    name_pascal = a_str
    name_pascal = name_pascal.replace(&#34;_&#34;, &#34; &#34;)
    name_pascal = name_pascal.replace(&#34;-&#34;, &#34; &#34;)
    name_pascal = name_pascal.title()
    name_pascal = name_pascal.replace(&#34; &#34;, &#34;&#34;)

    # return result
    return name_pascal</code></pre>
</details>
<div class="desc"><p>Format a string in Pascal case</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a_str</code></strong></dt>
<dd>A string to convert to Pascal case</dd>
</dl>
<p>Returns;
The Pascal cased string</p>
<p>Formats the given string to a Pascal case equivalent, ie. "my_class"
becomes "MyClass".</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.pp"><code class="name flex">
<span>def <span class="ident">pp</span></span>(<span>obj, indent_size=4, label=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pp(obj, indent_size=4, label=None):
    &#34;&#34;&#34;
    Pretty print a dictionary or list

    Args:
        obj: The dictionary or list to print
        indent_size: The number of spaces to use for each indent level
        (default: 4)
        label: The string to use as a label (default: None)

    Returns:
        The object formatted for printing

    Raises:
        OSError if the first param is not a dict or list

    Formats a dictionary or list nicely and prints it to the console. Note that
    this method includes magic commas in the output, and therefore cannot be
    used to create true JSON-compatible strings. It should only be used for
    debugging.
    &#34;&#34;&#34;

    # the default result
    result = &#34;&#34;

    # call different pretty functions depending on the object type
    if isinstance(obj, dict):
        result = dpretty(obj, indent_size, 0, label)
    elif isinstance(obj, list):
        result = lpretty(obj, indent_size, 0, label)
    else:
        raise OSError(S_ERR_NOT_DICT_OR_LIST)

    # print the result
    print(result)</code></pre>
</details>
<div class="desc"><p>Pretty print a dictionary or list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>The dictionary or list to print</dd>
<dt><strong><code>indent_size</code></strong></dt>
<dd>The number of spaces to use for each indent level</dd>
<dt>(default: 4)</dt>
<dt><strong><code>label</code></strong></dt>
<dd>The string to use as a label (default: None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The object formatted for printing</p>
<h2 id="raises">Raises</h2>
<p>OSError if the first param is not a dict or list
Formats a dictionary or list nicely and prints it to the console. Note that
this method includes magic commas in the output, and therefore cannot be
used to create true JSON-compatible strings. It should only be used for
debugging.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.save_dict"><code class="name flex">
<span>def <span class="ident">save_dict</span></span>(<span>a_dict, paths)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_dict(a_dict, paths):
    &#34;&#34;&#34;
    Save a dictionary to all paths

    Args:
        a_dict: The dictionary to save to the file
        paths: The path or list of paths to save to

    Raises:
        OSError: If the file does not exist and can&#39;t be created

    Save the dictionary to a file at all the specified locations.
    &#34;&#34;&#34;

    # sanity check
    if isinstance(paths, (str, Path)):
        paths = [paths]

    # loop through possible files
    for path in paths:

        # sanity check
        path = Path(path).resolve()

        # try each option
        try:

            # make sure path is absolute
            if not path.is_absolute():
                print(S_ERR_NOT_CREATE.format(path))
                continue

            # first make dirs
            path.parent.mkdir(parents=True, exist_ok=True)

            # open the file
            with open(path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as a_file:
                # save dict tp file
                json.dump(a_dict, a_file, indent=4)

        # raise an OS Error
        except OSError as e:
            raise OSError(S_ERR_NOT_CREATE.format(path)) from e</code></pre>
</details>
<div class="desc"><p>Save a dictionary to all paths</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a_dict</code></strong></dt>
<dd>The dictionary to save to the file</dd>
<dt><strong><code>paths</code></strong></dt>
<dd>The path or list of paths to save to</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OSError</code></dt>
<dd>If the file does not exist and can't be created</dd>
</dl>
<p>Save the dictionary to a file at all the specified locations.</p></div>
</dd>
<dt id="CNLib.cnlib.cnfunctions.sh"><code class="name flex">
<span>def <span class="ident">sh</span></span>(<span>cmd, shell=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sh(cmd, shell=False):
    &#34;&#34;&#34;
    Run a program or command string in the shell

    Args:
        cmd: The command line to run
        shell: If False (the default), run the cmd as one long string. If True,
        split the cmd into separate arguments

    Returns:
        The result of running the command line, as a
        subprocess.CompletedProcess object

    This is just a dumb convenience method to use subprocess with a string
    instead of having to convert a string to an array with shlex every time I
    need to run a shell command.
    &#34;&#34;&#34;

    # make sure it&#39;s a string (sometime pass path object)
    cmd = str(cmd)

    # split the string using shell syntax (smart split/quote)
    # NB: only split if running a file - if running a shell cmd, don&#39;t split
    if not shell:
        cmd = shlex.split(cmd)

    # get result of running the shell command or bubble up an error
    try:
        res = subprocess.run(
            # the array of commands produced by shlex.split
            cmd,
            # if check is True, an exception will be raised if the return code
            # is not 0
            # if check is False, no exception is raised but res will be None,
            # meaning you have to test for it in the calling function
            # but that also means you have no information on WHY it failed
            check=True,
            # convert stdout/stderr from bytes to text
            text=True,
            # put stdout/stderr into res
            capture_output=True,
            # whether the call is a file w/ params (False) or a direct shell
            # input (True)
            shell=shell,
        )

    # check if it failed
    except subprocess.CalledProcessError as e:
        raise OSError(S_ERR_SHELL) from e

    # return the result
    return res</code></pre>
</details>
<div class="desc"><p>Run a program or command string in the shell</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>The command line to run</dd>
<dt><strong><code>shell</code></strong></dt>
<dd>If False (the default), run the cmd as one long string. If True,</dd>
</dl>
<p>split the cmd into separate arguments</p>
<h2 id="returns">Returns</h2>
<p>The result of running the command line, as a
subprocess.CompletedProcess object
This is just a dumb convenience method to use subprocess with a string
instead of having to convert a string to an array with shlex every time I
need to run a shell command.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" href="https://github.com/cyclopticnerve/CNLib">
<!-- image will get fixed into local img -->
<img src="../img/cnlib.png"/>CNLib
</a>
<br/>
<!-- __RM_VERSION__ -->
Version 0.0.4
<!-- __RM_VERSION__ -->
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CNLib.cnlib" href="index.html">CNLib.cnlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="CNLib.cnlib.cnfunctions.combine_dicts" href="#CNLib.cnlib.cnfunctions.combine_dicts">combine_dicts</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.compare_versions" href="#CNLib.cnlib.cnfunctions.compare_versions">compare_versions</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.dialog" href="#CNLib.cnlib.cnfunctions.dialog">dialog</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.do_bool" href="#CNLib.cnlib.cnfunctions.do_bool">do_bool</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.dpretty" href="#CNLib.cnlib.cnfunctions.dpretty">dpretty</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.fix_globs" href="#CNLib.cnlib.cnfunctions.fix_globs">fix_globs</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.get_dict_from_file" href="#CNLib.cnlib.cnfunctions.get_dict_from_file">get_dict_from_file</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.load_dicts" href="#CNLib.cnlib.cnfunctions.load_dicts">load_dicts</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.lpretty" href="#CNLib.cnlib.cnfunctions.lpretty">lpretty</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.pascal_case" href="#CNLib.cnlib.cnfunctions.pascal_case">pascal_case</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.pp" href="#CNLib.cnlib.cnfunctions.pp">pp</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.save_dict" href="#CNLib.cnlib.cnfunctions.save_dict">save_dict</a></code></li>
<li><code><a title="CNLib.cnlib.cnfunctions.sh" href="#CNLib.cnlib.cnfunctions.sh">sh</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
