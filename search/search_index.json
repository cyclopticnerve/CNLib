{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CNLib \"It mostly works\" \u2122\u00a9\u00ae A Python library containing useful functions and classes Version 0.0.0 Table of Contents Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes Requirements Python 3.10+ Downloading There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/CNLib Installing There are also two ways to get CNLib into your project. Run these commands from your project directory. First make sure you have a venv and it is active: $ python -m venv .venv $ . .venv/bin/activate Manually If you downloaded the zip file: $ python -m pip install /path/to/CNLib-<version>.zip where \\<version> is the version number included in the file name. Or if you cloned the repo: $ python -m pip install /path/to/CNLib Automagically Add this line to your project's 'requirements.txt' file: CNLib @ git+https://github.com/cyclopticnerve/CNLib@<tag> where \\<tag> is the tag you want, such as 'v0.0.1', etc. Then run: $ python -m pip install -r requirements.txt Usage Read the full documentation . Uninstalling In your project folder: $ . ..venv-cnlib/bin/activate $ python -m pip uninstall cnlib Documentation See the full documentation . Developing If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv). Notes 10/10, no notes. -)","title":"Home"},{"location":"#cnlib","text":"","title":"CNLib"},{"location":"#it-mostly-works-tm","text":"A Python library containing useful functions and classes Version 0.0.0","title":"\"It mostly works\" \u2122\u00a9\u00ae"},{"location":"#table-of-contents","text":"Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes","title":"Table of Contents"},{"location":"#requirements","text":"Python 3.10+","title":"Requirements"},{"location":"#downloading","text":"There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/CNLib","title":"Downloading"},{"location":"#installing","text":"There are also two ways to get CNLib into your project. Run these commands from your project directory. First make sure you have a venv and it is active: $ python -m venv .venv $ . .venv/bin/activate","title":"Installing"},{"location":"#manually","text":"If you downloaded the zip file: $ python -m pip install /path/to/CNLib-<version>.zip where \\<version> is the version number included in the file name. Or if you cloned the repo: $ python -m pip install /path/to/CNLib","title":"Manually"},{"location":"#automagically","text":"Add this line to your project's 'requirements.txt' file: CNLib @ git+https://github.com/cyclopticnerve/CNLib@<tag> where \\<tag> is the tag you want, such as 'v0.0.1', etc. Then run: $ python -m pip install -r requirements.txt","title":"Automagically"},{"location":"#usage","text":"Read the full documentation .","title":"Usage"},{"location":"#uninstalling","text":"In your project folder: $ . ..venv-cnlib/bin/activate $ python -m pip uninstall cnlib","title":"Uninstalling"},{"location":"#documentation","text":"See the full documentation .","title":"Documentation"},{"location":"#developing","text":"If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv).","title":"Developing"},{"location":"#notes","text":"10/10, no notes. -)","title":"Notes"},{"location":"API/cnlib/cnformatter/","text":"cnformatter.py A dummy class to combine multiple argparse formatters CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in cnlib/cnformatter.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"cnformatter.py"},{"location":"API/cnlib/cnformatter/#cnformatterpy","text":"A dummy class to combine multiple argparse formatters","title":"cnformatter.py"},{"location":"API/cnlib/cnformatter/#cnlib.cnformatter.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in cnlib/cnformatter.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/cnlib/cnfunctions/","text":"cnfunctions.py A collection of common functions used by CN software Functions: Name Description pascal_case Convert a class name to it's Pascal equivalent do_bool Convert other values, like integers or strings, to bools dpretty Pretty print a dict lpretty Pretty print a list pp Pretty print a dictionary or list combine_dicts Update a dictionary with one or more dictionaries sh Run a command string in the shell load_dicts Combines dictionaries from all found paths save_dict Save a dictionary to all paths CNRunError Bases: Exception A class to encapsulate run exceptions Source code in cnlib/cnfunctions.py class CNRunError(Exception): \"\"\" A class to encapsulate run exceptions \"\"\" # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self, cmd, returncode, stdout, stderr, output): \"\"\" Docstring for __init__ :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description \"\"\" # call super __init__ super().__init__() # set properties from params self.cmd = cmd self.returncode = returncode self.stdout = stdout self.stderr = stderr self.output = output # -------------------------------------------------------------------------- # Return a string representation of an instance of the class # -------------------------------------------------------------------------- def __str__(self): return ( f\"cmd: {self.cmd}, \" f\"returncode: {self.returncode}, \" f\"stdout: {self.stdout}, \" f\"stderr: {self.stderr}, \" f\"output: {self.output}\" ) __init__(cmd, returncode, stdout, stderr, output) Docstring for init :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description Source code in cnlib/cnfunctions.py def __init__(self, cmd, returncode, stdout, stderr, output): \"\"\" Docstring for __init__ :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description \"\"\" # call super __init__ super().__init__() # set properties from params self.cmd = cmd self.returncode = returncode self.stdout = stdout self.stderr = stderr self.output = output combine_dicts(dicts_new, dict_old=None) Update a dictionary with entries from another dict Parameters: Name Type Description Default dicts_new A dictionary or list of dictionaries containing new required dict_old The dictionary defined as the one to receive updates None (default None) required Returns: Type Description The updated dict_old, filled with updates from dict_new This function takes key/value pairs from each of the new dicts and adds/overwrites these keys and values in dict_old, preserving any values that are blank or None in dict_new. It is also recursive, so a dict or list as a value will be handled correctly. *NOTE: This function DOES NOT test for type mismatches in values for matching keys!!! So if a new dict has a key of \"A\" and a value of type \"str\", and the old dict has a key of \"A\" with a value of type \"int\", bad things will happen!!! Source code in cnlib/cnfunctions.py def combine_dicts(dicts_new, dict_old=None): \"\"\" Update a dictionary with entries from another dict Args: dicts_new: A dictionary or list of dictionaries containing new keys/values to be updated in the old dictionary dict_old: The dictionary defined as the one to receive updates (default: None) Returns: The updated dict_old, filled with updates from dict_new This function takes key/value pairs from each of the new dicts and adds/overwrites these keys and values in dict_old, preserving any values that are blank or None in dict_new. It is also recursive, so a dict or list as a value will be handled correctly. *NOTE: This function DOES NOT test for type mismatches in values for matching keys!!! So if a new dict has a key of \"A\" and a value of type \"str\", and the old dict has a key of \"A\" with a value of type \"int\", bad things will happen!!! \"\"\" # default return val if not dict_old: dict_old = {} else: dict_old = dict(dict_old) # sanity checks if not isinstance(dicts_new, list): dicts_new = [dicts_new] if len(dicts_new) == 0: return dict_old # go through the new dicts in order for dict_new in dicts_new: # for each k,v pair in dict_new for k, v in dict_new.items(): # if the value is a dict if isinstance(v, dict): # recurse using the current key and value dict_old[k] = combine_dicts(v, dict_old.get(k, None)) continue # if the value is not a dict or a list # just copy value from one dict to the other dict_old[k] = v # return the updated dict_old return dict_old comp_sem_ver(ver_old, ver_new) Compare two semantic versions Parameters: Name Type Description Default ver_old The old version to compare required ver_new The new version to compare required Returns: Type Description An integer showing the relationship between the two version Compare two semantic versions. Source code in cnlib/cnfunctions.py def comp_sem_ver(ver_old, ver_new): \"\"\" Compare two semantic versions Args: ver_old: The old version to compare ver_new: The new version to compare Returns: An integer showing the relationship between the two version Compare two semantic versions. \"\"\" # sanity checks if not ver_old or ver_old == \"\": return I_VER_ERROR if not ver_new or ver_new == \"\": return I_VER_ERROR if ver_old == ver_new: return I_VER_SAME # -------------------------------------------------------------------------- # compare version string parts (only x.x.x) res_old = re.search(R_VERSION_VALID, ver_old) res_new = re.search(R_VERSION_VALID, ver_new) # if either version string is None if not res_old or not res_new: return I_VER_ERROR # make a list of groups to check lst_groups = [ R_VERSION_GROUP_MAJ, R_VERSION_GROUP_MIN, R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return I_VER_NEWER if old_val > new_val: return I_VER_OLDER # -------------------------------------------------------------------------- # still going, check pre pre_old = res_old.group(R_VERSION_GROUP_PRE) pre_new = res_new.group(R_VERSION_GROUP_PRE) # simple pre rule compare if not pre_old and pre_new: return I_VER_OLDER if pre_old and not pre_new: return I_VER_NEWER if not pre_old and not pre_new: return I_VER_SAME # -------------------------------------------------------------------------- # if pre_old and pre_new: # split pre on dots lst_pre_old = pre_old.split(\".\") lst_pre_new = pre_new.split(\".\") # get number of parts len_pre_old = len(lst_pre_old) len_pre_new = len(lst_pre_new) # get shorter of two shortest = len_pre_old if len_pre_old <= len_pre_new else len_pre_new # for each part in shortest for index in range(shortest): # get each value at position old_val = lst_pre_old[index] new_val = lst_pre_new[index] # 1. both numbers if old_val.isdigit() and new_val.isdigit(): tmp_old_val = int(old_val) tmp_new_val = int(new_val) # slide out at the first difference if tmp_old_val > tmp_new_val: return I_VER_OLDER if tmp_old_val < tmp_new_val: return I_VER_NEWER # 2. both alphanumeric if not old_val.isdigit() and not new_val.isdigit(): lst_alpha = [old_val, new_val] lst_alpha.sort() idx_old = lst_alpha.index(old_val) idx_new = lst_alpha.index(new_val) if idx_old > idx_new: return I_VER_OLDER if idx_old < idx_new: return I_VER_NEWER # 3 num vs alphanumeric if old_val.isdigit() and not new_val.isdigit(): return I_VER_OLDER if not old_val.isdigit() and new_val.isdigit(): return I_VER_NEWER # 4 len if len_pre_old > len_pre_new: return I_VER_OLDER if len_pre_new > len_pre_old: return I_VER_NEWER # -------------------------------------------------------------------------- # error in one or both versions return I_VER_SAME dialog(message, buttons, default='', loop=False, btn_sep='/', msg_fmt='{} [{}]: ') Create a dialog-like question and return the result Parameters: Name Type Description Default message The message to display required buttons List of single char answers to the question required default The button item to return when the user presses Enter at the question (default: \"\") '' loop If True and the user enters an invalid response, keep asking the False (default False) required btn_sep Char to use to separate button items '/' msg_fmt Format string to present message/buttons to the user '{} [{}]: ' Returns: Type Description A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. Source code in cnlib/cnfunctions.py def dialog( message, buttons, default=\"\", loop=False, btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at the question (default: \"\") loop: If True and the user enters an invalid response, keep asking the question. If False, return an empty string for an invalid response (default: False) btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. \"\"\" # -------------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # -------------------------------------------------------------------------- # assume loop == True while True: # ask the question, get the result (first char only/empty) inp = input(str_fmt) # if len(inp) > 0: # inp = inp[0] # no input (empty) if inp == \"\" and default != \"\": return default # input a button for item in buttons: if inp.lower() == item.lower(): return item # ------------------------------------------------------------------ # wrong answer # no loop, return blank if not loop: return \"\" do_bool(val) Convert other values, like integers or strings, to bools Parameters: Name Type Description Default val The value to convert to a bool required Returns: Type Description A boolean value converted from the argument Converts integers and strings to boolean values based on the rules. Source code in cnlib/cnfunctions.py def do_bool(val): \"\"\" Convert other values, like integers or strings, to bools Args: val: The value to convert to a bool Returns: A boolean value converted from the argument Converts integers and strings to boolean values based on the rules. \"\"\" # lower all test vals rules_true = [item.lower() for item in L_RULES_TRUE] # return result return str(val).lower() in rules_true dpretty(dict_print, indent_size=4, indent_level=0, label=None) Pretty print a dict Parameters: Name Type Description Default dict_print The dictionary to print required indent_size The number of spaces to use for each indent level 4 (default 4) required indent_level The number of indent levels to use for this part of the 0 print process (default 0) required label The string to use as a label (default: None) None Returns: Type Description The formatted string to print Formats a dictionary nicely so it can be printed to the console. Source code in cnlib/cnfunctions.py def dpretty(dict_print, indent_size=4, indent_level=0, label=None): \"\"\" Pretty print a dict Args: dict_print: The dictionary to print indent_size: The number of spaces to use for each indent level (default: 4) indent_level: The number of indent levels to use for this part of the print process (default: 0) label: The string to use as a label (default: None) Returns: The formatted string to print Raises: OSError if the first param is not a dict Formats a dictionary nicely so it can be printed to the console. \"\"\" # sanity check if not isinstance(dict_print, dict): raise OSError(S_ERR_NOT_DICT) # default out out = \"\" # print label if label is not None: out += label + \": \" # convert indent_size to string and multiply by indent_level indent_str = (\" \" * indent_size) * (indent_level) # items will need an extra indent, since they don't recurse indent_str_next = (\" \" * indent_size) * (indent_level + 1) # default result opening brace (no indent in case it is nested and is # preceded by a key) out += indent_str + \"{\\n\" # for each entry for k, v in dict_print.items(): # print the key out += indent_str_next + f'\"{k}\": ' # if the value is a list if isinstance(v, list): # recurse the value and increase indent level ret = ( lpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) ret = ret.lstrip() out += ret # if the value is a dict elif isinstance(v, dict): # recurse the value and increase indent level ret = ( dpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) ret = ret.lstrip() out += ret # if it is a single entry (str, int, bool) else: # print the value, quoting it if it is a string if isinstance(v, str): out += f'\"{v}\",\\n' else: out += f\"{v},\\n\" # get original indent indent_str = (\" \" * indent_size) * indent_level # # add closing bracket out += indent_str + \"}\" # return result return out get_underscore(domain, path_locale) Return an underscore function for a module Source code in cnlib/cnfunctions.py def get_underscore(domain, path_locale): \"\"\" Return an underscore function for a module \"\"\" # fix locale (different than gettext stuff, mostly fixes GUI issues, but ok # to use for CLI in the interest of common code) locale.bindtextdomain(domain, path_locale) # init gettext t_translation = gettext.translation(domain, path_locale, fallback=True) return t_translation.gettext load_paths_into_dict(paths, start_dict=None) Combines dictionaries from all found paths Parameters: Name Type Description Default paths The file path or list of file paths to load required start_dict The starting dict and final dict after combining (default: None) None Returns: Type Description The final combined dictionary Raises: Type Description OSError If the file does not exist or the file is not a valid JSON Load the dictionaries from all files and use combine_dicts to combine them. Source code in cnlib/cnfunctions.py def load_paths_into_dict(paths, start_dict=None): \"\"\" Combines dictionaries from all found paths Args: paths: The file path or list of file paths to load start_dict: The starting dict and final dict after combining (default: None) Returns: The final combined dictionary Raises: OSError: If the file does not exist or the file is not a valid JSON file Load the dictionaries from all files and use combine_dicts to combine them. \"\"\" # sanity check if not isinstance(paths, list): paths = [paths] # set the default result if start_dict is None: start_dict = {} # loop through possible files for path in paths: # sanity checks if not path: continue path = Path(path).resolve() # try each option try: # open the file with open(path, \"r\", encoding=S_ENCODING) as a_file: # load dict from file new_dict = json.load(a_file) # combine new dict with previous start_dict = combine_dicts(new_dict, start_dict) # file not found except FileNotFoundError as e: raise OSError(S_ERR_NOT_FOUND.format(path)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(S_ERR_NOT_JSON.format(path)) from e # return the final dict return start_dict lpretty(list_print, indent_size=4, indent_level=0, label=None) Pretty print a list Parameters: Name Type Description Default list_print The list to print required indent_size The number of spaces to use for each indent level 4 (default 4) required indent_level The number of indent levels to use for this part of the 0 print process (default 0) required label The string to use as a label (default: None) None Returns: Type Description The formatted string to print Formats a list nicely so it can be printed to the console. Source code in cnlib/cnfunctions.py def lpretty(list_print, indent_size=4, indent_level=0, label=None): \"\"\" Pretty print a list Args: list_print: The list to print indent_size: The number of spaces to use for each indent level (default: 4) indent_level: The number of indent levels to use for this part of the print process (default: 0) label: The string to use as a label (default: None) Returns: The formatted string to print Raises: OSError if the first param is not a list Formats a list nicely so it can be printed to the console. \"\"\" # sanity check if not isinstance(list_print, list): raise OSError(S_ERR_NOT_LIST) # default out out = \"\" # print label if label is not None: out += label + \": \" # convert indent_size to string and multiply by indent_level indent_str = (\" \" * indent_size) * (indent_level) # items will need an extra indent, since they don't recurse indent_str_next = (\" \" * indent_size) * (indent_level + 1) # default result opening brace (no indent in case it is nested and is # preceded by a key) out += indent_str + \"[\\n\" # for each entry for v in list_print: # if the value is a list if isinstance(v, list): # recurse the value and increase indent level ret = ( lpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) out += ret # if the value is a dict elif isinstance(v, dict): # recurse the value and increase indent level ret = ( dpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) out += ret # if it is a single entry (str, int, bool) else: # print the value, quoting it if it is a string if isinstance(v, str): out += indent_str_next + f'\"{v}\",\\n' else: out += indent_str_next + f\"{v},\\n\" # get original indent indent_str = (\" \" * indent_size) * indent_level # # add closing bracket out += indent_str + \"]\" # return result return out pascal_case(a_str) Format a string in Pascal case Parameters: Name Type Description Default a_str A string to convert to Pascal case required Returns; The Pascal cased string Formats the given string to a Pascal case equivalent, ie. \"my_class\" becomes \"MyClass\". Source code in cnlib/cnfunctions.py def pascal_case(a_str): \"\"\" Format a string in Pascal case Args: a_str: A string to convert to Pascal case Returns; The Pascal cased string Formats the given string to a Pascal case equivalent, ie. \"my_class\" becomes \"MyClass\". \"\"\" # do formatting name_pascal = a_str name_pascal = name_pascal.replace(\"_\", \" \") name_pascal = name_pascal.replace(\"-\", \" \") name_pascal = name_pascal.title() name_pascal = name_pascal.replace(\" \", \"\") # return result return name_pascal pp(obj, indent_size=4, label=None) Pretty print a dictionary or list Parameters: Name Type Description Default obj The dictionary or list to print required indent_size The number of spaces to use for each indent level 4 (default 4) required label The string to use as a label (default: None) None Returns: Type Description The object formatted for printing Formats a dictionary or list nicely and prints it to the console. Note that this method includes magic commas in the output, and therefore cannot be used to create true JSON-compatible strings. It should only be used for debugging. Source code in cnlib/cnfunctions.py def pp(obj, indent_size=4, label=None): \"\"\" Pretty print a dictionary or list Args: obj: The dictionary or list to print indent_size: The number of spaces to use for each indent level (default: 4) label: The string to use as a label (default: None) Returns: The object formatted for printing Raises: OSError if the first param is not a dict or list Formats a dictionary or list nicely and prints it to the console. Note that this method includes magic commas in the output, and therefore cannot be used to create true JSON-compatible strings. It should only be used for debugging. \"\"\" # the default result result = \"\" # call different pretty functions depending on the object type if isinstance(obj, dict): result = dpretty(obj, indent_size, 0, label) elif isinstance(obj, list): result = lpretty(obj, indent_size, 0, label) else: raise OSError(S_ERR_NOT_DICT_OR_LIST) # print the result print(result) printc(*values, sep=' ', end='\\n', file=None, flush=False, fg=0, bg=0, bold=False) Print a string in color Parameters: Name Type Description Default *values A variable number of string arguments () sep The string used to join *values (default: ' ') ' ' end The character(s) to print after the *values (default:'\\n') '\\n' file The file object to print to or, if None, print to stdout (default: None) None flush Whether to force the output buffer to write immediately, rather than waiting for it to fill False fg The foreground color of the text as a C_FG_XXX value (see below). If 0, use default terminal color (default: 0) 0 bg The background color of the text as a C_FG_XXX value (see below). If 0, use default terminal color (default: 0) 0 bold Whether the text is bold (duh) (default:False) False This function prints something to the console, just like print(), but with COLOR! and BOLD! The first five parameters are EXACTLY the same as print() and the last three are as follows: fg: The foreground color of the text to print. This can be one of the following values: C_FG_NONE (use the terminal default) C_FG_BLACK C_FG_RED C_FG_GREEN C_FG_YELLOW C_FG_BLUE C_FG_MAGENTA C_FG_CYAN C_FG_WHITE bg: The background (or highlight) color of the text to print. This can be one of the following values: C_BG_NONE (use the terminal default) C_BG_BLACK C_BG_RED C_BG_GREEN C_BG_YELLOW C_BG_BLUE C_BG_MAGENTA C_BG_CYAN C_BG_WHITE A note about the background color: Setting the background color will (almost?) always set the foreground color to white. So no cyan text on a magenta background. Source code in cnlib/cnfunctions.py def printc( *values, sep=\" \", end=\"\\n\", file=None, flush=False, fg=0, bg=0, bold=False ): \"\"\" Print a string in color Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:'\\\\n') file: The file object to print to or, if None, print to stdout \\ (default: None) flush: Whether to force the output buffer to write immediately, \\ rather than waiting for it to fill fg: The foreground color of the text as a C_FG_XXX value (see below). \\ If 0, use default terminal color (default: 0) bg: The background color of the text as a C_FG_XXX value (see below). \\ If 0, use default terminal color (default: 0) bold: Whether the text is bold (duh) (default:False) This function prints something to the console, just like print(), but with COLOR! and BOLD!\\n The first five parameters are EXACTLY the same as print() and the last three are as follows:\\n \\n fg: The foreground color of the text to print. This can be one of the following values:\\n \\n C_FG_NONE (use the terminal default)\\n C_FG_BLACK\\n C_FG_RED\\n C_FG_GREEN\\n C_FG_YELLOW\\n C_FG_BLUE\\n C_FG_MAGENTA\\n C_FG_CYAN\\n C_FG_WHITE\\n \\n bg: The background (or highlight) color of the text to print. This can be one of the following values:\\n \\n C_BG_NONE (use the terminal default)\\n C_BG_BLACK\\n C_BG_RED\\n C_BG_GREEN\\n C_BG_YELLOW\\n C_BG_BLUE\\n C_BG_MAGENTA\\n C_BG_CYAN\\n C_BG_WHITE\\n \\n A note about the background color:\\n Setting the background color will (almost?) always set the foreground color to white. So no cyan text on a magenta background. \"\"\" # NB: every option has a unique value and order does not matter # the default array of text options arr_opt = [] # maybe set fg if fg != 0: arr_opt.append(str(fg)) # maybe set bg if bg != 0: arr_opt.append(str(bg)) # maybe set bold if bold: arr_opt.append(\"1\") # put arr_opt together color_val = \";\".join(arr_opt) # '32;42;1', '42' # get open sequence color_start = f\"\\033[{color_val}m\" # get the close sequence (reset fg/bg/bold) color_end = \"\\033[0m\" # ------------------------------------------------------------------------------ # get the full string value = sep.join(values) # split into lines lines = value.split(\"\\n\") # a list of newline-separated strings in the final string wrapped_lines = [] # for each string for line in lines: # wrap it and add it to the final string wrapped_lines.append(color_start + line + color_end) # rejoin strings using newline final_str = \"\\n\".join(wrapped_lines) print(final_str, sep=sep, end=end, file=file, flush=flush) printd(*values, sep=' ', end='\\n', file=None, flush=False) Print a string if the debug param is True Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:' ') file: The file object to print to or, if None, print to stdout (default: None) flush: Whether to force the output buffer to write immediately, rather than waiting for it to fill This function is really handy for me when I run a program in debug mode. It just lets me wrap prints in context-aware statements Source code in cnlib/cnfunctions.py def printd(*values, sep=\" \", end=\"\\n\", file=None, flush=False): \"\"\" Print a string if the debug param is True Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:'\\n') file: The file object to print to or, if None, print to stdout (default: None) flush: Whether to force the output buffer to write immediately, rather than waiting for it to fill This function is really handy for me when I run a program in debug mode. It just lets me wrap prints in context-aware statements \"\"\" if B_DEBUG: printc( *values, sep=sep, end=end, file=file, flush=flush, fg=C_FG_RED, bold=True, ) run(cmd, shell=False, capture_output=False) Run a program or shell command string Parameters: Name Type Description Default cmd The command to run required shell If False (the default), run the cmd as one long string. If True, False Returns: Type Description The result of running the command line, as a subprocess.CompletedProcess object This is just a dumb convenience method to use subprocess with a string instead of having to convert a string to an array with shlex every time. It also combines FileNotFoundError and CalledProcessError into one CNRunError. Source code in cnlib/cnfunctions.py def run(cmd, shell=False, capture_output=False): \"\"\" Run a program or shell command string Args: cmd: The command to run shell: If False (the default), run the cmd as one long string. If True, split the cmd into separate arguments Returns: The result of running the command line, as a subprocess.CompletedProcess object Raises: CNRunError if the command is invalid or the process fails This is just a dumb convenience method to use subprocess with a string instead of having to convert a string to an array with shlex every time. It also combines FileNotFoundError and CalledProcessError into one CNRunError. \"\"\" # sanity check to make sure cmd is a string cmd = str(cmd) # if not shell, split into bin/cli options # NB: if shell, we only want the stuff after [\"sh\", \"-c\"], which is what # would be typed at the command prompt (i.e. all one long command string) if not shell: cmd = shlex.split(cmd) # get result of running the shell command or bubble up an error try: cp = subprocess.run( # the cmd or array of commands cmd, # if check is True, an exception will be raised if the return code # is not 0 # if check is False, no exception is raised but cp will be None, # meaning you have to test for it in the calling function # but that also means you have no information on WHY it failed # because stderr comes from the CalledProcessError IF # capture_output=True check=True, # put stdout/stderr into cp/cpe capture_output=capture_output, # convert stdout/stderr from bytes to text encoding=S_ENCODING, text=True, # whether the call is a file w/ params (False) or a direct shell # input (True) shell=shell, ) # return the result return cp # the first item in the list is not a bin # NB: try these: # cmd = \"cd /\", shell = False: fail # cmd = \"cd /\", shell = True: pass # cmd = \"ls -l\", shell = False: pass # cmd = \"ls -l\", shell = True: pass # check if first item is bin, if shell false except FileNotFoundError as fnfe: # NB: fnfe already has a nice __str__, so use that in the stderr # also output = stdout, which is kinda pointless for this error # NB: print(exc) gives ALL properties # print(exc.stderr) give concise output exc = CNRunError( cmd, fnfe.errno, fnfe.filename, f\"{fnfe}\", fnfe.filename ) raise exc from fnfe # cmd ran but failed except subprocess.CalledProcessError as cpe: # NB: here we use the regular stderr as concise output exc = CNRunError( cpe.cmd, cpe.returncode, cpe.stdout, cpe.stderr, cpe.output ) raise exc from cpe save_dict_into_paths(save_dict, paths) Save a dictionary to all paths Parameters: Name Type Description Default save_dict The dictionary to save to the paths(s) required paths The path or list of paths to save to required Raises: Type Description OSError If the file does not exist and can't be created Save the dictionary to a file at all the specified locations. Source code in cnlib/cnfunctions.py def save_dict_into_paths(save_dict, paths): \"\"\" Save a dictionary to all paths Args: save_dict: The dictionary to save to the paths(s) paths: The path or list of paths to save to Raises: OSError: If the file does not exist and can't be created Save the dictionary to a file at all the specified locations. \"\"\" # sanity checks if not isinstance(paths, list): paths = [paths] if len(paths) == 0: return # loop through possible files for path in paths: # sanity checks if not path: continue path = Path(path).resolve() # try each path try: # first make dirs path.parent.mkdir(parents=True, exist_ok=True) # open the file with open(path, \"w\", encoding=S_ENCODING) as a_file: # save dict tp file json.dump(save_dict, a_file, indent=4) # raise an OS Error except OSError as e: raise OSError(S_ERR_NOT_CREATE.format(path)) from e","title":"cnfunctions.py"},{"location":"API/cnlib/cnfunctions/#cnfunctionspy","text":"A collection of common functions used by CN software Functions: Name Description pascal_case Convert a class name to it's Pascal equivalent do_bool Convert other values, like integers or strings, to bools dpretty Pretty print a dict lpretty Pretty print a list pp Pretty print a dictionary or list combine_dicts Update a dictionary with one or more dictionaries sh Run a command string in the shell load_dicts Combines dictionaries from all found paths save_dict Save a dictionary to all paths","title":"cnfunctions.py"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.CNRunError","text":"Bases: Exception A class to encapsulate run exceptions Source code in cnlib/cnfunctions.py class CNRunError(Exception): \"\"\" A class to encapsulate run exceptions \"\"\" # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self, cmd, returncode, stdout, stderr, output): \"\"\" Docstring for __init__ :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description \"\"\" # call super __init__ super().__init__() # set properties from params self.cmd = cmd self.returncode = returncode self.stdout = stdout self.stderr = stderr self.output = output # -------------------------------------------------------------------------- # Return a string representation of an instance of the class # -------------------------------------------------------------------------- def __str__(self): return ( f\"cmd: {self.cmd}, \" f\"returncode: {self.returncode}, \" f\"stdout: {self.stdout}, \" f\"stderr: {self.stderr}, \" f\"output: {self.output}\" )","title":"CNRunError"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.CNRunError.__init__","text":"Docstring for init :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description Source code in cnlib/cnfunctions.py def __init__(self, cmd, returncode, stdout, stderr, output): \"\"\" Docstring for __init__ :param self: Description :param cmd: Description :param returncode: Description :param stdout: Description :param stderr: Description :param output: Description \"\"\" # call super __init__ super().__init__() # set properties from params self.cmd = cmd self.returncode = returncode self.stdout = stdout self.stderr = stderr self.output = output","title":"__init__"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.combine_dicts","text":"Update a dictionary with entries from another dict Parameters: Name Type Description Default dicts_new A dictionary or list of dictionaries containing new required dict_old The dictionary defined as the one to receive updates None (default None) required Returns: Type Description The updated dict_old, filled with updates from dict_new This function takes key/value pairs from each of the new dicts and adds/overwrites these keys and values in dict_old, preserving any values that are blank or None in dict_new. It is also recursive, so a dict or list as a value will be handled correctly. *NOTE: This function DOES NOT test for type mismatches in values for matching keys!!! So if a new dict has a key of \"A\" and a value of type \"str\", and the old dict has a key of \"A\" with a value of type \"int\", bad things will happen!!! Source code in cnlib/cnfunctions.py def combine_dicts(dicts_new, dict_old=None): \"\"\" Update a dictionary with entries from another dict Args: dicts_new: A dictionary or list of dictionaries containing new keys/values to be updated in the old dictionary dict_old: The dictionary defined as the one to receive updates (default: None) Returns: The updated dict_old, filled with updates from dict_new This function takes key/value pairs from each of the new dicts and adds/overwrites these keys and values in dict_old, preserving any values that are blank or None in dict_new. It is also recursive, so a dict or list as a value will be handled correctly. *NOTE: This function DOES NOT test for type mismatches in values for matching keys!!! So if a new dict has a key of \"A\" and a value of type \"str\", and the old dict has a key of \"A\" with a value of type \"int\", bad things will happen!!! \"\"\" # default return val if not dict_old: dict_old = {} else: dict_old = dict(dict_old) # sanity checks if not isinstance(dicts_new, list): dicts_new = [dicts_new] if len(dicts_new) == 0: return dict_old # go through the new dicts in order for dict_new in dicts_new: # for each k,v pair in dict_new for k, v in dict_new.items(): # if the value is a dict if isinstance(v, dict): # recurse using the current key and value dict_old[k] = combine_dicts(v, dict_old.get(k, None)) continue # if the value is not a dict or a list # just copy value from one dict to the other dict_old[k] = v # return the updated dict_old return dict_old","title":"combine_dicts"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.comp_sem_ver","text":"Compare two semantic versions Parameters: Name Type Description Default ver_old The old version to compare required ver_new The new version to compare required Returns: Type Description An integer showing the relationship between the two version Compare two semantic versions. Source code in cnlib/cnfunctions.py def comp_sem_ver(ver_old, ver_new): \"\"\" Compare two semantic versions Args: ver_old: The old version to compare ver_new: The new version to compare Returns: An integer showing the relationship between the two version Compare two semantic versions. \"\"\" # sanity checks if not ver_old or ver_old == \"\": return I_VER_ERROR if not ver_new or ver_new == \"\": return I_VER_ERROR if ver_old == ver_new: return I_VER_SAME # -------------------------------------------------------------------------- # compare version string parts (only x.x.x) res_old = re.search(R_VERSION_VALID, ver_old) res_new = re.search(R_VERSION_VALID, ver_new) # if either version string is None if not res_old or not res_new: return I_VER_ERROR # make a list of groups to check lst_groups = [ R_VERSION_GROUP_MAJ, R_VERSION_GROUP_MIN, R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return I_VER_NEWER if old_val > new_val: return I_VER_OLDER # -------------------------------------------------------------------------- # still going, check pre pre_old = res_old.group(R_VERSION_GROUP_PRE) pre_new = res_new.group(R_VERSION_GROUP_PRE) # simple pre rule compare if not pre_old and pre_new: return I_VER_OLDER if pre_old and not pre_new: return I_VER_NEWER if not pre_old and not pre_new: return I_VER_SAME # -------------------------------------------------------------------------- # if pre_old and pre_new: # split pre on dots lst_pre_old = pre_old.split(\".\") lst_pre_new = pre_new.split(\".\") # get number of parts len_pre_old = len(lst_pre_old) len_pre_new = len(lst_pre_new) # get shorter of two shortest = len_pre_old if len_pre_old <= len_pre_new else len_pre_new # for each part in shortest for index in range(shortest): # get each value at position old_val = lst_pre_old[index] new_val = lst_pre_new[index] # 1. both numbers if old_val.isdigit() and new_val.isdigit(): tmp_old_val = int(old_val) tmp_new_val = int(new_val) # slide out at the first difference if tmp_old_val > tmp_new_val: return I_VER_OLDER if tmp_old_val < tmp_new_val: return I_VER_NEWER # 2. both alphanumeric if not old_val.isdigit() and not new_val.isdigit(): lst_alpha = [old_val, new_val] lst_alpha.sort() idx_old = lst_alpha.index(old_val) idx_new = lst_alpha.index(new_val) if idx_old > idx_new: return I_VER_OLDER if idx_old < idx_new: return I_VER_NEWER # 3 num vs alphanumeric if old_val.isdigit() and not new_val.isdigit(): return I_VER_OLDER if not old_val.isdigit() and new_val.isdigit(): return I_VER_NEWER # 4 len if len_pre_old > len_pre_new: return I_VER_OLDER if len_pre_new > len_pre_old: return I_VER_NEWER # -------------------------------------------------------------------------- # error in one or both versions return I_VER_SAME","title":"comp_sem_ver"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.dialog","text":"Create a dialog-like question and return the result Parameters: Name Type Description Default message The message to display required buttons List of single char answers to the question required default The button item to return when the user presses Enter at the question (default: \"\") '' loop If True and the user enters an invalid response, keep asking the False (default False) required btn_sep Char to use to separate button items '/' msg_fmt Format string to present message/buttons to the user '{} [{}]: ' Returns: Type Description A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. Source code in cnlib/cnfunctions.py def dialog( message, buttons, default=\"\", loop=False, btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at the question (default: \"\") loop: If True and the user enters an invalid response, keep asking the question. If False, return an empty string for an invalid response (default: False) btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. \"\"\" # -------------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # -------------------------------------------------------------------------- # assume loop == True while True: # ask the question, get the result (first char only/empty) inp = input(str_fmt) # if len(inp) > 0: # inp = inp[0] # no input (empty) if inp == \"\" and default != \"\": return default # input a button for item in buttons: if inp.lower() == item.lower(): return item # ------------------------------------------------------------------ # wrong answer # no loop, return blank if not loop: return \"\"","title":"dialog"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.do_bool","text":"Convert other values, like integers or strings, to bools Parameters: Name Type Description Default val The value to convert to a bool required Returns: Type Description A boolean value converted from the argument Converts integers and strings to boolean values based on the rules. Source code in cnlib/cnfunctions.py def do_bool(val): \"\"\" Convert other values, like integers or strings, to bools Args: val: The value to convert to a bool Returns: A boolean value converted from the argument Converts integers and strings to boolean values based on the rules. \"\"\" # lower all test vals rules_true = [item.lower() for item in L_RULES_TRUE] # return result return str(val).lower() in rules_true","title":"do_bool"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.dpretty","text":"Pretty print a dict Parameters: Name Type Description Default dict_print The dictionary to print required indent_size The number of spaces to use for each indent level 4 (default 4) required indent_level The number of indent levels to use for this part of the 0 print process (default 0) required label The string to use as a label (default: None) None Returns: Type Description The formatted string to print Formats a dictionary nicely so it can be printed to the console. Source code in cnlib/cnfunctions.py def dpretty(dict_print, indent_size=4, indent_level=0, label=None): \"\"\" Pretty print a dict Args: dict_print: The dictionary to print indent_size: The number of spaces to use for each indent level (default: 4) indent_level: The number of indent levels to use for this part of the print process (default: 0) label: The string to use as a label (default: None) Returns: The formatted string to print Raises: OSError if the first param is not a dict Formats a dictionary nicely so it can be printed to the console. \"\"\" # sanity check if not isinstance(dict_print, dict): raise OSError(S_ERR_NOT_DICT) # default out out = \"\" # print label if label is not None: out += label + \": \" # convert indent_size to string and multiply by indent_level indent_str = (\" \" * indent_size) * (indent_level) # items will need an extra indent, since they don't recurse indent_str_next = (\" \" * indent_size) * (indent_level + 1) # default result opening brace (no indent in case it is nested and is # preceded by a key) out += indent_str + \"{\\n\" # for each entry for k, v in dict_print.items(): # print the key out += indent_str_next + f'\"{k}\": ' # if the value is a list if isinstance(v, list): # recurse the value and increase indent level ret = ( lpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) ret = ret.lstrip() out += ret # if the value is a dict elif isinstance(v, dict): # recurse the value and increase indent level ret = ( dpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) ret = ret.lstrip() out += ret # if it is a single entry (str, int, bool) else: # print the value, quoting it if it is a string if isinstance(v, str): out += f'\"{v}\",\\n' else: out += f\"{v},\\n\" # get original indent indent_str = (\" \" * indent_size) * indent_level # # add closing bracket out += indent_str + \"}\" # return result return out","title":"dpretty"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.get_underscore","text":"Return an underscore function for a module Source code in cnlib/cnfunctions.py def get_underscore(domain, path_locale): \"\"\" Return an underscore function for a module \"\"\" # fix locale (different than gettext stuff, mostly fixes GUI issues, but ok # to use for CLI in the interest of common code) locale.bindtextdomain(domain, path_locale) # init gettext t_translation = gettext.translation(domain, path_locale, fallback=True) return t_translation.gettext","title":"get_underscore"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.load_paths_into_dict","text":"Combines dictionaries from all found paths Parameters: Name Type Description Default paths The file path or list of file paths to load required start_dict The starting dict and final dict after combining (default: None) None Returns: Type Description The final combined dictionary Raises: Type Description OSError If the file does not exist or the file is not a valid JSON Load the dictionaries from all files and use combine_dicts to combine them. Source code in cnlib/cnfunctions.py def load_paths_into_dict(paths, start_dict=None): \"\"\" Combines dictionaries from all found paths Args: paths: The file path or list of file paths to load start_dict: The starting dict and final dict after combining (default: None) Returns: The final combined dictionary Raises: OSError: If the file does not exist or the file is not a valid JSON file Load the dictionaries from all files and use combine_dicts to combine them. \"\"\" # sanity check if not isinstance(paths, list): paths = [paths] # set the default result if start_dict is None: start_dict = {} # loop through possible files for path in paths: # sanity checks if not path: continue path = Path(path).resolve() # try each option try: # open the file with open(path, \"r\", encoding=S_ENCODING) as a_file: # load dict from file new_dict = json.load(a_file) # combine new dict with previous start_dict = combine_dicts(new_dict, start_dict) # file not found except FileNotFoundError as e: raise OSError(S_ERR_NOT_FOUND.format(path)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(S_ERR_NOT_JSON.format(path)) from e # return the final dict return start_dict","title":"load_paths_into_dict"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.lpretty","text":"Pretty print a list Parameters: Name Type Description Default list_print The list to print required indent_size The number of spaces to use for each indent level 4 (default 4) required indent_level The number of indent levels to use for this part of the 0 print process (default 0) required label The string to use as a label (default: None) None Returns: Type Description The formatted string to print Formats a list nicely so it can be printed to the console. Source code in cnlib/cnfunctions.py def lpretty(list_print, indent_size=4, indent_level=0, label=None): \"\"\" Pretty print a list Args: list_print: The list to print indent_size: The number of spaces to use for each indent level (default: 4) indent_level: The number of indent levels to use for this part of the print process (default: 0) label: The string to use as a label (default: None) Returns: The formatted string to print Raises: OSError if the first param is not a list Formats a list nicely so it can be printed to the console. \"\"\" # sanity check if not isinstance(list_print, list): raise OSError(S_ERR_NOT_LIST) # default out out = \"\" # print label if label is not None: out += label + \": \" # convert indent_size to string and multiply by indent_level indent_str = (\" \" * indent_size) * (indent_level) # items will need an extra indent, since they don't recurse indent_str_next = (\" \" * indent_size) * (indent_level + 1) # default result opening brace (no indent in case it is nested and is # preceded by a key) out += indent_str + \"[\\n\" # for each entry for v in list_print: # if the value is a list if isinstance(v, list): # recurse the value and increase indent level ret = ( lpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) out += ret # if the value is a dict elif isinstance(v, dict): # recurse the value and increase indent level ret = ( dpretty( v, indent_size=indent_size, indent_level=indent_level + 1, label=None, ) + \"\\n\" ) out += ret # if it is a single entry (str, int, bool) else: # print the value, quoting it if it is a string if isinstance(v, str): out += indent_str_next + f'\"{v}\",\\n' else: out += indent_str_next + f\"{v},\\n\" # get original indent indent_str = (\" \" * indent_size) * indent_level # # add closing bracket out += indent_str + \"]\" # return result return out","title":"lpretty"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.pascal_case","text":"Format a string in Pascal case Parameters: Name Type Description Default a_str A string to convert to Pascal case required Returns; The Pascal cased string Formats the given string to a Pascal case equivalent, ie. \"my_class\" becomes \"MyClass\". Source code in cnlib/cnfunctions.py def pascal_case(a_str): \"\"\" Format a string in Pascal case Args: a_str: A string to convert to Pascal case Returns; The Pascal cased string Formats the given string to a Pascal case equivalent, ie. \"my_class\" becomes \"MyClass\". \"\"\" # do formatting name_pascal = a_str name_pascal = name_pascal.replace(\"_\", \" \") name_pascal = name_pascal.replace(\"-\", \" \") name_pascal = name_pascal.title() name_pascal = name_pascal.replace(\" \", \"\") # return result return name_pascal","title":"pascal_case"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.pp","text":"Pretty print a dictionary or list Parameters: Name Type Description Default obj The dictionary or list to print required indent_size The number of spaces to use for each indent level 4 (default 4) required label The string to use as a label (default: None) None Returns: Type Description The object formatted for printing Formats a dictionary or list nicely and prints it to the console. Note that this method includes magic commas in the output, and therefore cannot be used to create true JSON-compatible strings. It should only be used for debugging. Source code in cnlib/cnfunctions.py def pp(obj, indent_size=4, label=None): \"\"\" Pretty print a dictionary or list Args: obj: The dictionary or list to print indent_size: The number of spaces to use for each indent level (default: 4) label: The string to use as a label (default: None) Returns: The object formatted for printing Raises: OSError if the first param is not a dict or list Formats a dictionary or list nicely and prints it to the console. Note that this method includes magic commas in the output, and therefore cannot be used to create true JSON-compatible strings. It should only be used for debugging. \"\"\" # the default result result = \"\" # call different pretty functions depending on the object type if isinstance(obj, dict): result = dpretty(obj, indent_size, 0, label) elif isinstance(obj, list): result = lpretty(obj, indent_size, 0, label) else: raise OSError(S_ERR_NOT_DICT_OR_LIST) # print the result print(result)","title":"pp"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.printc","text":"Print a string in color Parameters: Name Type Description Default *values A variable number of string arguments () sep The string used to join *values (default: ' ') ' ' end The character(s) to print after the *values (default:'\\n') '\\n' file The file object to print to or, if None, print to stdout (default: None) None flush Whether to force the output buffer to write immediately, rather than waiting for it to fill False fg The foreground color of the text as a C_FG_XXX value (see below). If 0, use default terminal color (default: 0) 0 bg The background color of the text as a C_FG_XXX value (see below). If 0, use default terminal color (default: 0) 0 bold Whether the text is bold (duh) (default:False) False This function prints something to the console, just like print(), but with COLOR! and BOLD! The first five parameters are EXACTLY the same as print() and the last three are as follows: fg: The foreground color of the text to print. This can be one of the following values: C_FG_NONE (use the terminal default) C_FG_BLACK C_FG_RED C_FG_GREEN C_FG_YELLOW C_FG_BLUE C_FG_MAGENTA C_FG_CYAN C_FG_WHITE bg: The background (or highlight) color of the text to print. This can be one of the following values: C_BG_NONE (use the terminal default) C_BG_BLACK C_BG_RED C_BG_GREEN C_BG_YELLOW C_BG_BLUE C_BG_MAGENTA C_BG_CYAN C_BG_WHITE A note about the background color: Setting the background color will (almost?) always set the foreground color to white. So no cyan text on a magenta background. Source code in cnlib/cnfunctions.py def printc( *values, sep=\" \", end=\"\\n\", file=None, flush=False, fg=0, bg=0, bold=False ): \"\"\" Print a string in color Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:'\\\\n') file: The file object to print to or, if None, print to stdout \\ (default: None) flush: Whether to force the output buffer to write immediately, \\ rather than waiting for it to fill fg: The foreground color of the text as a C_FG_XXX value (see below). \\ If 0, use default terminal color (default: 0) bg: The background color of the text as a C_FG_XXX value (see below). \\ If 0, use default terminal color (default: 0) bold: Whether the text is bold (duh) (default:False) This function prints something to the console, just like print(), but with COLOR! and BOLD!\\n The first five parameters are EXACTLY the same as print() and the last three are as follows:\\n \\n fg: The foreground color of the text to print. This can be one of the following values:\\n \\n C_FG_NONE (use the terminal default)\\n C_FG_BLACK\\n C_FG_RED\\n C_FG_GREEN\\n C_FG_YELLOW\\n C_FG_BLUE\\n C_FG_MAGENTA\\n C_FG_CYAN\\n C_FG_WHITE\\n \\n bg: The background (or highlight) color of the text to print. This can be one of the following values:\\n \\n C_BG_NONE (use the terminal default)\\n C_BG_BLACK\\n C_BG_RED\\n C_BG_GREEN\\n C_BG_YELLOW\\n C_BG_BLUE\\n C_BG_MAGENTA\\n C_BG_CYAN\\n C_BG_WHITE\\n \\n A note about the background color:\\n Setting the background color will (almost?) always set the foreground color to white. So no cyan text on a magenta background. \"\"\" # NB: every option has a unique value and order does not matter # the default array of text options arr_opt = [] # maybe set fg if fg != 0: arr_opt.append(str(fg)) # maybe set bg if bg != 0: arr_opt.append(str(bg)) # maybe set bold if bold: arr_opt.append(\"1\") # put arr_opt together color_val = \";\".join(arr_opt) # '32;42;1', '42' # get open sequence color_start = f\"\\033[{color_val}m\" # get the close sequence (reset fg/bg/bold) color_end = \"\\033[0m\" # ------------------------------------------------------------------------------ # get the full string value = sep.join(values) # split into lines lines = value.split(\"\\n\") # a list of newline-separated strings in the final string wrapped_lines = [] # for each string for line in lines: # wrap it and add it to the final string wrapped_lines.append(color_start + line + color_end) # rejoin strings using newline final_str = \"\\n\".join(wrapped_lines) print(final_str, sep=sep, end=end, file=file, flush=flush)","title":"printc"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.printd","text":"Print a string if the debug param is True Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:' ') file: The file object to print to or, if None, print to stdout (default: None) flush: Whether to force the output buffer to write immediately, rather than waiting for it to fill This function is really handy for me when I run a program in debug mode. It just lets me wrap prints in context-aware statements Source code in cnlib/cnfunctions.py def printd(*values, sep=\" \", end=\"\\n\", file=None, flush=False): \"\"\" Print a string if the debug param is True Args: *values: A variable number of string arguments sep: The string used to join *values (default: ' ') end: The character(s) to print after the *values (default:'\\n') file: The file object to print to or, if None, print to stdout (default: None) flush: Whether to force the output buffer to write immediately, rather than waiting for it to fill This function is really handy for me when I run a program in debug mode. It just lets me wrap prints in context-aware statements \"\"\" if B_DEBUG: printc( *values, sep=sep, end=end, file=file, flush=flush, fg=C_FG_RED, bold=True, )","title":"printd"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.run","text":"Run a program or shell command string Parameters: Name Type Description Default cmd The command to run required shell If False (the default), run the cmd as one long string. If True, False Returns: Type Description The result of running the command line, as a subprocess.CompletedProcess object This is just a dumb convenience method to use subprocess with a string instead of having to convert a string to an array with shlex every time. It also combines FileNotFoundError and CalledProcessError into one CNRunError. Source code in cnlib/cnfunctions.py def run(cmd, shell=False, capture_output=False): \"\"\" Run a program or shell command string Args: cmd: The command to run shell: If False (the default), run the cmd as one long string. If True, split the cmd into separate arguments Returns: The result of running the command line, as a subprocess.CompletedProcess object Raises: CNRunError if the command is invalid or the process fails This is just a dumb convenience method to use subprocess with a string instead of having to convert a string to an array with shlex every time. It also combines FileNotFoundError and CalledProcessError into one CNRunError. \"\"\" # sanity check to make sure cmd is a string cmd = str(cmd) # if not shell, split into bin/cli options # NB: if shell, we only want the stuff after [\"sh\", \"-c\"], which is what # would be typed at the command prompt (i.e. all one long command string) if not shell: cmd = shlex.split(cmd) # get result of running the shell command or bubble up an error try: cp = subprocess.run( # the cmd or array of commands cmd, # if check is True, an exception will be raised if the return code # is not 0 # if check is False, no exception is raised but cp will be None, # meaning you have to test for it in the calling function # but that also means you have no information on WHY it failed # because stderr comes from the CalledProcessError IF # capture_output=True check=True, # put stdout/stderr into cp/cpe capture_output=capture_output, # convert stdout/stderr from bytes to text encoding=S_ENCODING, text=True, # whether the call is a file w/ params (False) or a direct shell # input (True) shell=shell, ) # return the result return cp # the first item in the list is not a bin # NB: try these: # cmd = \"cd /\", shell = False: fail # cmd = \"cd /\", shell = True: pass # cmd = \"ls -l\", shell = False: pass # cmd = \"ls -l\", shell = True: pass # check if first item is bin, if shell false except FileNotFoundError as fnfe: # NB: fnfe already has a nice __str__, so use that in the stderr # also output = stdout, which is kinda pointless for this error # NB: print(exc) gives ALL properties # print(exc.stderr) give concise output exc = CNRunError( cmd, fnfe.errno, fnfe.filename, f\"{fnfe}\", fnfe.filename ) raise exc from fnfe # cmd ran but failed except subprocess.CalledProcessError as cpe: # NB: here we use the regular stderr as concise output exc = CNRunError( cpe.cmd, cpe.returncode, cpe.stdout, cpe.stderr, cpe.output ) raise exc from cpe","title":"run"},{"location":"API/cnlib/cnfunctions/#cnlib.cnfunctions.save_dict_into_paths","text":"Save a dictionary to all paths Parameters: Name Type Description Default save_dict The dictionary to save to the paths(s) required paths The path or list of paths to save to required Raises: Type Description OSError If the file does not exist and can't be created Save the dictionary to a file at all the specified locations. Source code in cnlib/cnfunctions.py def save_dict_into_paths(save_dict, paths): \"\"\" Save a dictionary to all paths Args: save_dict: The dictionary to save to the paths(s) paths: The path or list of paths to save to Raises: OSError: If the file does not exist and can't be created Save the dictionary to a file at all the specified locations. \"\"\" # sanity checks if not isinstance(paths, list): paths = [paths] if len(paths) == 0: return # loop through possible files for path in paths: # sanity checks if not path: continue path = Path(path).resolve() # try each path try: # first make dirs path.parent.mkdir(parents=True, exist_ok=True) # open the file with open(path, \"w\", encoding=S_ENCODING) as a_file: # save dict tp file json.dump(save_dict, a_file, indent=4) # raise an OS Error except OSError as e: raise OSError(S_ERR_NOT_CREATE.format(path)) from e","title":"save_dict_into_paths"},{"location":"API/cnlib/cninstall/","text":"cninstall.py The class to use for installing/uninstalling CNInstall The class to use for installing/uninstalling Methods: Name Description make_install_cfg Make a valid install config file make_uninstall_cfg Make a valid uninstall config file fix_desktop_file Fix .desktop file, for paths and such install Install the program uninstall Uninstall the program This class provides functions to create install/uninstall config files, and performs the install and uninstall operations. Source code in cnlib/cninstall.py class CNInstall: \"\"\" The class to use for installing/uninstalling Methods: make_install_cfg: Make a valid install config file make_uninstall_cfg: Make a valid uninstall config file fix_desktop_file: Fix .desktop file, for paths and such install: Install the program uninstall: Uninstall the program This class provides functions to create install/uninstall config files, and performs the install and uninstall operations. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version S_MSG_INST_START = \"Installing {} Version {}\" # NB: format param is prog_name S_MSG_INST_END = \"{} installed\" # NB: format param is prog_name S_MSG_UNINST_START = \"Uninstalling {}\" # NB: format param is prog_name S_MSG_UNINST_END = \"{} uninstalled\" S_MSG_DONE = \"Done\" S_MSG_FAIL = \"Fail\" # strings for system requirements S_MSG_COPY_START = \"Copying files... \" S_MSG_DEL_START = \"Deleting files... \" S_MSG_VENV_START = \"Making venv folder... \" S_MSG_REQS_START = \"Installing requirements... \" S_MSG_LIBS_START = \"Installing libs... \" S_MSG_DSK_START = \"Fixing .desktop file... \" S_MSG_ABORT = \"Installation aborted\" # errors S_ERR_NO_SUDO = \"Could not get sudo permission\" # NB: format param is source path S_ERR_SRC_PATH = \"src can not be {}\" # NB: format param is dest path S_ERR_DST_PATH = \"dst can not be {}\" # debug option strings S_DRY_OPTION = \"-d\" S_DRY_ACTION = \"store_true\" S_DRY_DEST = \"DBG_DEST\" S_DRY_HELP = \"do a dry run, printing file info instead of modifying it\" # questions S_ASK_YES = \"y\" S_ASK_NO = \"N\" S_ASK_VER_SAME = \"The current version of this program is already \\ installed. Do you want to overwrite?\" S_ASK_VER_OLDER = \"A newer version of this program is currently \\ installed. Do you want to overwrite?\" # NB: format param is __PP_NAME_PRJ_BIG__ S_ASK_UNINST = \"This will uninstall {}.\\nDo you want to continue?\" # encoding S_ENCODING = \"UTF-8\" # -------------------------------------------------------------------------- # NB: format param is path to icon S_DRY_DESK_ICON = \"desktop_icon: {}\" # commands # NB: format param is dir_venv # S_CMD_CREATE = \"python -Xfrozen_modules=off -m venv {}\" # # NB: format params are path to prj, path to venv, and path to reqs file # S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # # NB: format params are path to prj, path to venv # S_CMD_VENV_ACTIVATE = \"cd {};. {}/bin/activate\" # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set properties self._dry_run = False self._dict_cfg = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make a valid install config file # -------------------------------------------------------------------------- def make_install_cfg(self, name, version, dict_install, desk=False): \"\"\" Make a valid install config file Args: name: Program name version: New version number to compare to any installed version dict_install: Dict of assets to install desk:Whether to make a .desktop file for the program Returns: A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_DESK: desk, self.S_KEY_INST_CONT: dict_install, } # return the formatted dict return dict_use # -------------------------------------------------------------------------- # Make a valid uninstall config file # -------------------------------------------------------------------------- def make_uninstall_cfg(self, name, version, list_uninst): \"\"\" Make a valid uninstall config file Args: name: Program name version: Initial program version from pyplate.py list_uninstall: List of assets to uninstall desk: Whether to delete a .desktop file for the program Returns: A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_CONT: list_uninst, } # return the formatted dict return dict_use # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def fix_desktop_file(self, desk_file, path_icon, dry=False): \"\"\" Fix .desktop file, for paths and such Args: desk_file: The path to the desktop file to be modified path_icon: The path to the program's icon, relative to user home dry: If True, do not copy files, ony print the action (default: False) Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # sanity check # NB: in a cli or pkg, this file will not exist if not desk_file.exists(): return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # open file text = \"\" with open(desk_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / path_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ---------------------------------------------------------------------- # don't mess with file if dry: print(self.S_DRY_DESK_ICON.format(path_icon)) return # write fixed text back to file with open(desk_file, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def install( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, dry_run=False, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer path_lib: Path to the dist's lib folder, ie. \"assets/lib\" path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_usr_inst: The program's install folder in which to make a venv dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv dry: If True, do not copy files, ony print the action (default: False) Runs the install operation. \"\"\" # set properties self._dry_run = dry_run # get install dict try: F.load_paths_into_dict(path_cfg_inst, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print() print(self.S_MSG_INST_START.format(prog_name, prog_version)) # ---------------------------------------------------------------------- # draw the rest of the owl self._compare_version(path_cfg_uninst) # make the venv on the user's comp self._make_venv(dir_usr_inst, dir_venv, path_reqs) # fix desktop file if present self._fix_desktop_file(file_desk, file_desk_icon) # move content self._install_content(dir_assets) print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def uninstall(self, path_cfg, dry_run=False): \"\"\" Uninstall the program Args: path_cfg: Path to the file that contains the uninstall dict info dry: If True, do not remove files, ony print the action (default: False) Runs the uninstall operation. \"\"\" # set properties self._dry_run = dry_run # get dict from file try: F.load_paths_into_dict(path_cfg, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # print print() print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall self._do_uninstall_content() print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Check the version installed vs version to be installed # -------------------------------------------------------------------------- def _compare_version(self, path_cfg_uninst): \"\"\" Check the version installed vs version to be installed \"\"\" # ---------------------------------------------------------------------- # check for existing/old version # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if path_cfg_uninst and Path(path_cfg_uninst).exists(): try: dict_cfg_old = F.load_paths_into_dict(path_cfg_uninst) except OSError as e: raise e # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] res = F.comp_sem_ver(ver_old, ver_new) # same version is installed if res == F.I_VER_SAME: # ask to install same version str_ask = F.dialog( self.S_ASK_VER_SAME, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # newer version is installed elif res == F.I_VER_OLDER: # ask to install old version over newer str_ask = F.dialog( self.S_ASK_VER_OLDER, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == F.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self, dir_usr_inst, dir_venv, path_reqs): \"\"\" Make venv for this program on user's computer Args: dir_usr_inst: The program's install folder in which to make a venv folder. dir_venv: The path to the venv folder to create. Raises: cnlib.cnfunctions.CNRunError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # sanity check # dir_venv = Path(dir_venv) # if not dir_venv.is_absolute(): # dir_venv = Path(dir_usr_inst) / dir_venv # # the command to create a venv # cmd = self.S_CMD_CREATE.format(dir_venv) # if it's a dry run, don't make venv if self._dry_run: cmd = CNVenv.S_CMD_CREATE.format(dir_venv) print(\"\\nvenv cmd:\", cmd) print(self.S_MSG_DONE, \"\\n\") return # do the thing with the thing try: cv = CNVenv(dir_usr_inst, dir_venv) cv.create() cv.install_reqs(path_reqs) F.printc(self.S_MSG_DONE, fg=F.C_FG_GREEN, bold=True) except F.CNRunError as e: # exit gracefully F.printc(self.S_MSG_FAIL, fg=F.C_FG_RED, bold=True) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self, file_desk, file_desk_icon): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(file_desk_icon)) print(self.S_MSG_DONE) return # sanity check (params to main might be None) if not file_desk or not file_desk_icon: print(\"no desktop files present\") return # open file text = \"\" with open(file_desk, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(file_desk, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self, dir_assets): \"\"\" Copy source files/folders Args: dir_assets: The base dir from which to find install files This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # add an extra line break if self._dry_run: print() # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = dir_assets / k dst = Path.home() / v / src.name if k in (\"\", \".\", \"..\", None): print(self.S_ERR_SRC_PATH.format(k)) sys.exit(-1) if v in (\"\", \".\", \"..\") or src.name in (\"\", \".\", \"..\"): print(self.S_ERR_DST_PATH.format(v)) sys.exit(-1) # debug may omit certain assets if not src.exists(): continue if self._dry_run: print(f\"copy\\n{src}\\nto\\n{dst}\\n\") else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Remove source files/folders # -------------------------------------------------------------------------- def _do_uninstall_content(self): \"\"\" Remove source files/folders This method removes files and folders from various locations in the user's computer. \"\"\" # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # make pretty if self._dry_run: print() # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # weed out relative paths if item in (\"\", \".\", \"..\"): print(self.S_ERR_DST_PATH.format(item)) sys.exit(-1) # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(f\"remove\\n{item}\\n\") else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE) __init__() Initialize the class Creates a new instance of the object and initializes its properties. Source code in cnlib/cninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set properties self._dry_run = False self._dict_cfg = {} fix_desktop_file(desk_file, path_icon, dry=False) Fix .desktop file, for paths and such Parameters: Name Type Description Default desk_file The path to the desktop file to be modified required path_icon The path to the program's icon, relative to user home required dry If True, do not copy files, ony print the action (default: False Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. Source code in cnlib/cninstall.py def fix_desktop_file(self, desk_file, path_icon, dry=False): \"\"\" Fix .desktop file, for paths and such Args: desk_file: The path to the desktop file to be modified path_icon: The path to the program's icon, relative to user home dry: If True, do not copy files, ony print the action (default: False) Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # sanity check # NB: in a cli or pkg, this file will not exist if not desk_file.exists(): return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # open file text = \"\" with open(desk_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / path_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ---------------------------------------------------------------------- # don't mess with file if dry: print(self.S_DRY_DESK_ICON.format(path_icon)) return # write fixed text back to file with open(desk_file, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) install(dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, dry_run=False) Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required path_lib Path to the dist's lib folder, ie. \"assets/lib\" required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_usr_inst The program's install folder in which to make a venv required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required dry If True, do not copy files, ony print the action (default: required Runs the install operation. Source code in cnlib/cninstall.py def install( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, dry_run=False, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer path_lib: Path to the dist's lib folder, ie. \"assets/lib\" path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_usr_inst: The program's install folder in which to make a venv dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv dry: If True, do not copy files, ony print the action (default: False) Runs the install operation. \"\"\" # set properties self._dry_run = dry_run # get install dict try: F.load_paths_into_dict(path_cfg_inst, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print() print(self.S_MSG_INST_START.format(prog_name, prog_version)) # ---------------------------------------------------------------------- # draw the rest of the owl self._compare_version(path_cfg_uninst) # make the venv on the user's comp self._make_venv(dir_usr_inst, dir_venv, path_reqs) # fix desktop file if present self._fix_desktop_file(file_desk, file_desk_icon) # move content self._install_content(dir_assets) print(self.S_MSG_INST_END.format(prog_name)) make_install_cfg(name, version, dict_install, desk=False) Make a valid install config file Parameters: Name Type Description Default name Program name required version New version number to compare to any installed version required dict_install Dict of assets to install required desk Whether to make a .desktop file for the program False Returns: Type Description A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. Source code in cnlib/cninstall.py def make_install_cfg(self, name, version, dict_install, desk=False): \"\"\" Make a valid install config file Args: name: Program name version: New version number to compare to any installed version dict_install: Dict of assets to install desk:Whether to make a .desktop file for the program Returns: A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_DESK: desk, self.S_KEY_INST_CONT: dict_install, } # return the formatted dict return dict_use make_uninstall_cfg(name, version, list_uninst) Make a valid uninstall config file Parameters: Name Type Description Default name Program name required version Initial program version from pyplate.py required list_uninstall List of assets to uninstall required desk Whether to delete a .desktop file for the program required Returns: Type Description A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. Source code in cnlib/cninstall.py def make_uninstall_cfg(self, name, version, list_uninst): \"\"\" Make a valid uninstall config file Args: name: Program name version: Initial program version from pyplate.py list_uninstall: List of assets to uninstall desk: Whether to delete a .desktop file for the program Returns: A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_CONT: list_uninst, } # return the formatted dict return dict_use uninstall(path_cfg, dry_run=False) Uninstall the program Parameters: Name Type Description Default path_cfg Path to the file that contains the uninstall dict info required dry If True, do not remove files, ony print the action (default: required Runs the uninstall operation. Source code in cnlib/cninstall.py def uninstall(self, path_cfg, dry_run=False): \"\"\" Uninstall the program Args: path_cfg: Path to the file that contains the uninstall dict info dry: If True, do not remove files, ony print the action (default: False) Runs the uninstall operation. \"\"\" # set properties self._dry_run = dry_run # get dict from file try: F.load_paths_into_dict(path_cfg, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # print print() print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall self._do_uninstall_content() print(self.S_MSG_UNINST_END.format(prog_name))","title":"cninstall.py"},{"location":"API/cnlib/cninstall/#cninstallpy","text":"The class to use for installing/uninstalling","title":"cninstall.py"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall","text":"The class to use for installing/uninstalling Methods: Name Description make_install_cfg Make a valid install config file make_uninstall_cfg Make a valid uninstall config file fix_desktop_file Fix .desktop file, for paths and such install Install the program uninstall Uninstall the program This class provides functions to create install/uninstall config files, and performs the install and uninstall operations. Source code in cnlib/cninstall.py class CNInstall: \"\"\" The class to use for installing/uninstalling Methods: make_install_cfg: Make a valid install config file make_uninstall_cfg: Make a valid uninstall config file fix_desktop_file: Fix .desktop file, for paths and such install: Install the program uninstall: Uninstall the program This class provides functions to create install/uninstall config files, and performs the install and uninstall operations. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version S_MSG_INST_START = \"Installing {} Version {}\" # NB: format param is prog_name S_MSG_INST_END = \"{} installed\" # NB: format param is prog_name S_MSG_UNINST_START = \"Uninstalling {}\" # NB: format param is prog_name S_MSG_UNINST_END = \"{} uninstalled\" S_MSG_DONE = \"Done\" S_MSG_FAIL = \"Fail\" # strings for system requirements S_MSG_COPY_START = \"Copying files... \" S_MSG_DEL_START = \"Deleting files... \" S_MSG_VENV_START = \"Making venv folder... \" S_MSG_REQS_START = \"Installing requirements... \" S_MSG_LIBS_START = \"Installing libs... \" S_MSG_DSK_START = \"Fixing .desktop file... \" S_MSG_ABORT = \"Installation aborted\" # errors S_ERR_NO_SUDO = \"Could not get sudo permission\" # NB: format param is source path S_ERR_SRC_PATH = \"src can not be {}\" # NB: format param is dest path S_ERR_DST_PATH = \"dst can not be {}\" # debug option strings S_DRY_OPTION = \"-d\" S_DRY_ACTION = \"store_true\" S_DRY_DEST = \"DBG_DEST\" S_DRY_HELP = \"do a dry run, printing file info instead of modifying it\" # questions S_ASK_YES = \"y\" S_ASK_NO = \"N\" S_ASK_VER_SAME = \"The current version of this program is already \\ installed. Do you want to overwrite?\" S_ASK_VER_OLDER = \"A newer version of this program is currently \\ installed. Do you want to overwrite?\" # NB: format param is __PP_NAME_PRJ_BIG__ S_ASK_UNINST = \"This will uninstall {}.\\nDo you want to continue?\" # encoding S_ENCODING = \"UTF-8\" # -------------------------------------------------------------------------- # NB: format param is path to icon S_DRY_DESK_ICON = \"desktop_icon: {}\" # commands # NB: format param is dir_venv # S_CMD_CREATE = \"python -Xfrozen_modules=off -m venv {}\" # # NB: format params are path to prj, path to venv, and path to reqs file # S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # # NB: format params are path to prj, path to venv # S_CMD_VENV_ACTIVATE = \"cd {};. {}/bin/activate\" # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set properties self._dry_run = False self._dict_cfg = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make a valid install config file # -------------------------------------------------------------------------- def make_install_cfg(self, name, version, dict_install, desk=False): \"\"\" Make a valid install config file Args: name: Program name version: New version number to compare to any installed version dict_install: Dict of assets to install desk:Whether to make a .desktop file for the program Returns: A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_DESK: desk, self.S_KEY_INST_CONT: dict_install, } # return the formatted dict return dict_use # -------------------------------------------------------------------------- # Make a valid uninstall config file # -------------------------------------------------------------------------- def make_uninstall_cfg(self, name, version, list_uninst): \"\"\" Make a valid uninstall config file Args: name: Program name version: Initial program version from pyplate.py list_uninstall: List of assets to uninstall desk: Whether to delete a .desktop file for the program Returns: A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_CONT: list_uninst, } # return the formatted dict return dict_use # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def fix_desktop_file(self, desk_file, path_icon, dry=False): \"\"\" Fix .desktop file, for paths and such Args: desk_file: The path to the desktop file to be modified path_icon: The path to the program's icon, relative to user home dry: If True, do not copy files, ony print the action (default: False) Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # sanity check # NB: in a cli or pkg, this file will not exist if not desk_file.exists(): return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # open file text = \"\" with open(desk_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / path_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ---------------------------------------------------------------------- # don't mess with file if dry: print(self.S_DRY_DESK_ICON.format(path_icon)) return # write fixed text back to file with open(desk_file, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def install( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, dry_run=False, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer path_lib: Path to the dist's lib folder, ie. \"assets/lib\" path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_usr_inst: The program's install folder in which to make a venv dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv dry: If True, do not copy files, ony print the action (default: False) Runs the install operation. \"\"\" # set properties self._dry_run = dry_run # get install dict try: F.load_paths_into_dict(path_cfg_inst, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print() print(self.S_MSG_INST_START.format(prog_name, prog_version)) # ---------------------------------------------------------------------- # draw the rest of the owl self._compare_version(path_cfg_uninst) # make the venv on the user's comp self._make_venv(dir_usr_inst, dir_venv, path_reqs) # fix desktop file if present self._fix_desktop_file(file_desk, file_desk_icon) # move content self._install_content(dir_assets) print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def uninstall(self, path_cfg, dry_run=False): \"\"\" Uninstall the program Args: path_cfg: Path to the file that contains the uninstall dict info dry: If True, do not remove files, ony print the action (default: False) Runs the uninstall operation. \"\"\" # set properties self._dry_run = dry_run # get dict from file try: F.load_paths_into_dict(path_cfg, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # print print() print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall self._do_uninstall_content() print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Check the version installed vs version to be installed # -------------------------------------------------------------------------- def _compare_version(self, path_cfg_uninst): \"\"\" Check the version installed vs version to be installed \"\"\" # ---------------------------------------------------------------------- # check for existing/old version # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if path_cfg_uninst and Path(path_cfg_uninst).exists(): try: dict_cfg_old = F.load_paths_into_dict(path_cfg_uninst) except OSError as e: raise e # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] res = F.comp_sem_ver(ver_old, ver_new) # same version is installed if res == F.I_VER_SAME: # ask to install same version str_ask = F.dialog( self.S_ASK_VER_SAME, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # newer version is installed elif res == F.I_VER_OLDER: # ask to install old version over newer str_ask = F.dialog( self.S_ASK_VER_OLDER, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == F.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self, dir_usr_inst, dir_venv, path_reqs): \"\"\" Make venv for this program on user's computer Args: dir_usr_inst: The program's install folder in which to make a venv folder. dir_venv: The path to the venv folder to create. Raises: cnlib.cnfunctions.CNRunError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # sanity check # dir_venv = Path(dir_venv) # if not dir_venv.is_absolute(): # dir_venv = Path(dir_usr_inst) / dir_venv # # the command to create a venv # cmd = self.S_CMD_CREATE.format(dir_venv) # if it's a dry run, don't make venv if self._dry_run: cmd = CNVenv.S_CMD_CREATE.format(dir_venv) print(\"\\nvenv cmd:\", cmd) print(self.S_MSG_DONE, \"\\n\") return # do the thing with the thing try: cv = CNVenv(dir_usr_inst, dir_venv) cv.create() cv.install_reqs(path_reqs) F.printc(self.S_MSG_DONE, fg=F.C_FG_GREEN, bold=True) except F.CNRunError as e: # exit gracefully F.printc(self.S_MSG_FAIL, fg=F.C_FG_RED, bold=True) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self, file_desk, file_desk_icon): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(file_desk_icon)) print(self.S_MSG_DONE) return # sanity check (params to main might be None) if not file_desk or not file_desk_icon: print(\"no desktop files present\") return # open file text = \"\" with open(file_desk, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(file_desk, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self, dir_assets): \"\"\" Copy source files/folders Args: dir_assets: The base dir from which to find install files This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # add an extra line break if self._dry_run: print() # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = dir_assets / k dst = Path.home() / v / src.name if k in (\"\", \".\", \"..\", None): print(self.S_ERR_SRC_PATH.format(k)) sys.exit(-1) if v in (\"\", \".\", \"..\") or src.name in (\"\", \".\", \"..\"): print(self.S_ERR_DST_PATH.format(v)) sys.exit(-1) # debug may omit certain assets if not src.exists(): continue if self._dry_run: print(f\"copy\\n{src}\\nto\\n{dst}\\n\") else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Remove source files/folders # -------------------------------------------------------------------------- def _do_uninstall_content(self): \"\"\" Remove source files/folders This method removes files and folders from various locations in the user's computer. \"\"\" # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # make pretty if self._dry_run: print() # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # weed out relative paths if item in (\"\", \".\", \"..\"): print(self.S_ERR_DST_PATH.format(item)) sys.exit(-1) # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(f\"remove\\n{item}\\n\") else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE)","title":"CNInstall"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.__init__","text":"Initialize the class Creates a new instance of the object and initializes its properties. Source code in cnlib/cninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set properties self._dry_run = False self._dict_cfg = {}","title":"__init__"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.fix_desktop_file","text":"Fix .desktop file, for paths and such Parameters: Name Type Description Default desk_file The path to the desktop file to be modified required path_icon The path to the program's icon, relative to user home required dry If True, do not copy files, ony print the action (default: False Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. Source code in cnlib/cninstall.py def fix_desktop_file(self, desk_file, path_icon, dry=False): \"\"\" Fix .desktop file, for paths and such Args: desk_file: The path to the desktop file to be modified path_icon: The path to the program's icon, relative to user home dry: If True, do not copy files, ony print the action (default: False) Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # sanity check # NB: in a cli or pkg, this file will not exist if not desk_file.exists(): return # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # open file text = \"\" with open(desk_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / path_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ---------------------------------------------------------------------- # don't mess with file if dry: print(self.S_DRY_DESK_ICON.format(path_icon)) return # write fixed text back to file with open(desk_file, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text)","title":"fix_desktop_file"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.install","text":"Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required path_lib Path to the dist's lib folder, ie. \"assets/lib\" required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_usr_inst The program's install folder in which to make a venv required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required dry If True, do not copy files, ony print the action (default: required Runs the install operation. Source code in cnlib/cninstall.py def install( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, dry_run=False, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer path_lib: Path to the dist's lib folder, ie. \"assets/lib\" path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_usr_inst: The program's install folder in which to make a venv dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv dry: If True, do not copy files, ony print the action (default: False) Runs the install operation. \"\"\" # set properties self._dry_run = dry_run # get install dict try: F.load_paths_into_dict(path_cfg_inst, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print() print(self.S_MSG_INST_START.format(prog_name, prog_version)) # ---------------------------------------------------------------------- # draw the rest of the owl self._compare_version(path_cfg_uninst) # make the venv on the user's comp self._make_venv(dir_usr_inst, dir_venv, path_reqs) # fix desktop file if present self._fix_desktop_file(file_desk, file_desk_icon) # move content self._install_content(dir_assets) print(self.S_MSG_INST_END.format(prog_name))","title":"install"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.make_install_cfg","text":"Make a valid install config file Parameters: Name Type Description Default name Program name required version New version number to compare to any installed version required dict_install Dict of assets to install required desk Whether to make a .desktop file for the program False Returns: Type Description A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. Source code in cnlib/cninstall.py def make_install_cfg(self, name, version, dict_install, desk=False): \"\"\" Make a valid install config file Args: name: Program name version: New version number to compare to any installed version dict_install: Dict of assets to install desk:Whether to make a .desktop file for the program Returns: A properly formatted install config dict to save to a file This method creates a config file for use by install.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_DESK: desk, self.S_KEY_INST_CONT: dict_install, } # return the formatted dict return dict_use","title":"make_install_cfg"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.make_uninstall_cfg","text":"Make a valid uninstall config file Parameters: Name Type Description Default name Program name required version Initial program version from pyplate.py required list_uninstall List of assets to uninstall required desk Whether to delete a .desktop file for the program required Returns: Type Description A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. Source code in cnlib/cninstall.py def make_uninstall_cfg(self, name, version, list_uninst): \"\"\" Make a valid uninstall config file Args: name: Program name version: Initial program version from pyplate.py list_uninstall: List of assets to uninstall desk: Whether to delete a .desktop file for the program Returns: A properly formatted uninstall config dict to save to a file This method creates a config file for use by uninstall.py. The dict format can be found below. \"\"\" # create the dict using args dict_use = { self.S_KEY_INST_NAME: name, self.S_KEY_INST_VER: version, self.S_KEY_INST_CONT: list_uninst, } # return the formatted dict return dict_use","title":"make_uninstall_cfg"},{"location":"API/cnlib/cninstall/#cnlib.cninstall.CNInstall.uninstall","text":"Uninstall the program Parameters: Name Type Description Default path_cfg Path to the file that contains the uninstall dict info required dry If True, do not remove files, ony print the action (default: required Runs the uninstall operation. Source code in cnlib/cninstall.py def uninstall(self, path_cfg, dry_run=False): \"\"\" Uninstall the program Args: path_cfg: Path to the file that contains the uninstall dict info dry: If True, do not remove files, ony print the action (default: False) Runs the uninstall operation. \"\"\" # set properties self._dry_run = dry_run # get dict from file try: F.load_paths_into_dict(path_cfg, start_dict=self._dict_cfg) except OSError as e: raise e # get prg name prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit(-1) # print print() print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall self._do_uninstall_content() print(self.S_MSG_UNINST_END.format(prog_name))","title":"uninstall"},{"location":"API/cnlib/cnmkdocs/","text":"cnmkdocs.py This module makes documentation for a project using MkDocs. It uses the project's source files and the config file \"mkdocs.yml\" to create MarkDown files in the \"docs\" folder. It then builds the html file structure in the \"site\" folder. It uses the \"gh-deploy\" program to publish the site to a remote-only branch. It then instructs GitHub Pages to auto-publish your docs at <username>.github.io/<repo_name> from that branch. As much code/settings/constants as can be are reused from conf.py. CNMkDocs A class to handle making and baking documentation Source code in cnlib/cnmkdocs.py class CNMkDocs: \"\"\" A class to handle making and baking documentation \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # cmd for mkdocs # NB: format params are path to pp, path to pp venv, and path to project S_CMD_DOC_BUILD = \". {}/bin/activate;cd {};mkdocs build\" # cmd for mkdocs # NB: format params are path to pp, path to pp venv, and path to project S_CMD_DOC_DEPLOY = \". {}/bin/activate;cd {};mkdocs gh-deploy\" # file ext for in/out S_EXT_IN = \".py\" S_EXT_OUT = \".md\" # default to include mkdocstrings content in .md file # NB: format params are file name and formatted pkg name, done in make_docs S_DEF_FILE = \"# {}\\n::: {}\" # default encoding S_ENCODING = \"UTF-8\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # NB: DO NOT CHANGE!!! self._index_name = \"index.md\" self._dir_img = \"img\" # -------------------------------------------------------------------------- # Public functions # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make docs using mkdocs # -------------------------------------------------------------------------- def make_docs( self, dir_prj, dir_docs, use_rm=False, use_api=False, lst_api_in=None, file_rm=None, dir_api_out=None, dir_img=None, ): \"\"\" Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description \"\"\" # NB: mutable lists are only set once, passing an empty list does # NUSSING!!! # so we pass None to make sure the internal list gets reset if not lst_api_in: lst_api_in = [] # ---------------------------------------------------------------------- # check docs dir for exist # find docs dir dir_docs = Path(dir_prj) / dir_docs # no docs folder in template if not dir_docs.exists(): # make dir dir_docs.mkdir(parents=True) # make img dir # NB: the name of this dir is hard-coded in mkdocs (AFAIK) # it is used exclusively to serve the favicon.ico # paths to readme images, etc, can use a different dir img_dir = dir_docs / self._dir_img img_dir.mkdir(parents=True) # ---------------------------------------------------------------------- # make index # make empty or from readme or don't touch self._make_index(dir_prj, use_rm, file_rm, dir_docs) # ---------------------------------------------------------------------- # make api # make new api or delete old self._make_api(dir_prj, use_api, lst_api_in, dir_api_out, dir_docs) # ---------------------------------------------------------------------- # make img dir # dir_img is source (from project main) if dir_img: # make new img dir or combine dir_img_src = Path(dir_prj) / dir_img if dir_img_src.exists(): dir_img_dst = dir_docs / dir_img shutil.copytree(dir_img_src, dir_img_dst, dirs_exist_ok=True) # -------------------------------------------------------------------------- # Bake docs using mkdocs # -------------------------------------------------------------------------- def build_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # build docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_BUILD.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Deploy docs using mkdocs # -------------------------------------------------------------------------- def deploy_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # deploy docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_DEPLOY.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Private functions # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make the home file (index.md) # -------------------------------------------------------------------------- def _make_index(self, dir_prj, use_rm, file_rm, dir_docs): \"\"\" Make the home file (index.md) Make the index.md file from the README. \"\"\" # first check if index exists dir_docs_out = Path(dir_prj) / dir_docs path_index = dir_docs_out / self._index_name # if not exist if not path_index.exists(): # create empty file if not use_rm: with open(path_index, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(\"Coming soon...\") return # if exist else: # leave alone if not use_rm: return # ---------------------------------------------------------------------- # make home page # NB: just copy readme.md to index.md if use_rm: # path to files readme_file = Path(dir_prj) / file_rm # read input file text = \"\" with open(readme_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # write file with open(path_index, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # Make the api files # -------------------------------------------------------------------------- def _make_api(self, dir_prj, use_api, lst_api_in, dir_api_out, dir_docs): \"\"\" Make the api files Make the documents using the specified parameters. \"\"\" # sanity check if not dir_api_out: return # find api dir dir_prj = Path(dir_prj) dir_docs_out = dir_prj / dir_docs dir_api_out = dir_docs_out / dir_api_out # nuke it if it exists and we changed out mind if not use_api and dir_api_out.exists(): shutil.rmtree(dir_api_out) return # ---------------------------------------------------------------------- # gather list of full paths to .py files files_out = [] for item in lst_api_in: dir_api = dir_prj / item # NB: root is a full path, dirs and files are relative to root for root, _root_dirs, root_files in dir_api.walk(): # convert files into Paths files = [root / f for f in root_files] files = [ f for f in files if f.suffix.lower() == self.S_EXT_IN.lower() ] # for each file item for item in files: files_out.append(item) # ---------------------------------------------------------------------- # make structure # nuke / remake the api folder if dir_api_out.exists(): # delete and recreate dir shutil.rmtree(dir_api_out) dir_api_out.mkdir(parents=True) # for each py file for f in files_out: # make a parent folder in docs (goes in nav bar) # NB: basically we find every .py file and get its path relative to # project dir # then we make a folder with the same relative path, but rel to docs # dir path_rel = f.relative_to(dir_prj) path_doc = dir_api_out / path_rel.parent path_doc.mkdir(parents=True, exist_ok=True) # create a default file # NB: just swap \".py\" ext for \".md\" file_md = path_doc / Path(str(f.stem) + self.S_EXT_OUT) # fix rel path into package dot notation s_parts = \".\".join(path_rel.parts) if s_parts.endswith(self.S_EXT_IN): s_parts = s_parts.removesuffix(self.S_EXT_IN) # format contents of file file_fmt = self.S_DEF_FILE.format(f.name, s_parts) with open(file_md, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(file_fmt) __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in cnlib/cnmkdocs.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # NB: DO NOT CHANGE!!! self._index_name = \"index.md\" self._dir_img = \"img\" build_docs(p_dir_pp_venv, p_dir_prj) Bake docs using mkdocs Updates and deploys docs using mkdocs. Source code in cnlib/cnmkdocs.py def build_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # build docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_BUILD.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e deploy_docs(p_dir_pp_venv, p_dir_prj) Bake docs using mkdocs Updates and deploys docs using mkdocs. Source code in cnlib/cnmkdocs.py def deploy_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # deploy docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_DEPLOY.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e make_docs(dir_prj, dir_docs, use_rm=False, use_api=False, lst_api_in=None, file_rm=None, dir_api_out=None, dir_img=None) Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description Source code in cnlib/cnmkdocs.py def make_docs( self, dir_prj, dir_docs, use_rm=False, use_api=False, lst_api_in=None, file_rm=None, dir_api_out=None, dir_img=None, ): \"\"\" Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description \"\"\" # NB: mutable lists are only set once, passing an empty list does # NUSSING!!! # so we pass None to make sure the internal list gets reset if not lst_api_in: lst_api_in = [] # ---------------------------------------------------------------------- # check docs dir for exist # find docs dir dir_docs = Path(dir_prj) / dir_docs # no docs folder in template if not dir_docs.exists(): # make dir dir_docs.mkdir(parents=True) # make img dir # NB: the name of this dir is hard-coded in mkdocs (AFAIK) # it is used exclusively to serve the favicon.ico # paths to readme images, etc, can use a different dir img_dir = dir_docs / self._dir_img img_dir.mkdir(parents=True) # ---------------------------------------------------------------------- # make index # make empty or from readme or don't touch self._make_index(dir_prj, use_rm, file_rm, dir_docs) # ---------------------------------------------------------------------- # make api # make new api or delete old self._make_api(dir_prj, use_api, lst_api_in, dir_api_out, dir_docs) # ---------------------------------------------------------------------- # make img dir # dir_img is source (from project main) if dir_img: # make new img dir or combine dir_img_src = Path(dir_prj) / dir_img if dir_img_src.exists(): dir_img_dst = dir_docs / dir_img shutil.copytree(dir_img_src, dir_img_dst, dirs_exist_ok=True)","title":"cnmkdocs.py"},{"location":"API/cnlib/cnmkdocs/#cnmkdocspy","text":"This module makes documentation for a project using MkDocs. It uses the project's source files and the config file \"mkdocs.yml\" to create MarkDown files in the \"docs\" folder. It then builds the html file structure in the \"site\" folder. It uses the \"gh-deploy\" program to publish the site to a remote-only branch. It then instructs GitHub Pages to auto-publish your docs at <username>.github.io/<repo_name> from that branch. As much code/settings/constants as can be are reused from conf.py.","title":"cnmkdocs.py"},{"location":"API/cnlib/cnmkdocs/#cnlib.cnmkdocs.CNMkDocs","text":"A class to handle making and baking documentation Source code in cnlib/cnmkdocs.py class CNMkDocs: \"\"\" A class to handle making and baking documentation \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # cmd for mkdocs # NB: format params are path to pp, path to pp venv, and path to project S_CMD_DOC_BUILD = \". {}/bin/activate;cd {};mkdocs build\" # cmd for mkdocs # NB: format params are path to pp, path to pp venv, and path to project S_CMD_DOC_DEPLOY = \". {}/bin/activate;cd {};mkdocs gh-deploy\" # file ext for in/out S_EXT_IN = \".py\" S_EXT_OUT = \".md\" # default to include mkdocstrings content in .md file # NB: format params are file name and formatted pkg name, done in make_docs S_DEF_FILE = \"# {}\\n::: {}\" # default encoding S_ENCODING = \"UTF-8\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # NB: DO NOT CHANGE!!! self._index_name = \"index.md\" self._dir_img = \"img\" # -------------------------------------------------------------------------- # Public functions # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make docs using mkdocs # -------------------------------------------------------------------------- def make_docs( self, dir_prj, dir_docs, use_rm=False, use_api=False, lst_api_in=None, file_rm=None, dir_api_out=None, dir_img=None, ): \"\"\" Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description \"\"\" # NB: mutable lists are only set once, passing an empty list does # NUSSING!!! # so we pass None to make sure the internal list gets reset if not lst_api_in: lst_api_in = [] # ---------------------------------------------------------------------- # check docs dir for exist # find docs dir dir_docs = Path(dir_prj) / dir_docs # no docs folder in template if not dir_docs.exists(): # make dir dir_docs.mkdir(parents=True) # make img dir # NB: the name of this dir is hard-coded in mkdocs (AFAIK) # it is used exclusively to serve the favicon.ico # paths to readme images, etc, can use a different dir img_dir = dir_docs / self._dir_img img_dir.mkdir(parents=True) # ---------------------------------------------------------------------- # make index # make empty or from readme or don't touch self._make_index(dir_prj, use_rm, file_rm, dir_docs) # ---------------------------------------------------------------------- # make api # make new api or delete old self._make_api(dir_prj, use_api, lst_api_in, dir_api_out, dir_docs) # ---------------------------------------------------------------------- # make img dir # dir_img is source (from project main) if dir_img: # make new img dir or combine dir_img_src = Path(dir_prj) / dir_img if dir_img_src.exists(): dir_img_dst = dir_docs / dir_img shutil.copytree(dir_img_src, dir_img_dst, dirs_exist_ok=True) # -------------------------------------------------------------------------- # Bake docs using mkdocs # -------------------------------------------------------------------------- def build_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # build docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_BUILD.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Deploy docs using mkdocs # -------------------------------------------------------------------------- def deploy_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # deploy docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_DEPLOY.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Private functions # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Make the home file (index.md) # -------------------------------------------------------------------------- def _make_index(self, dir_prj, use_rm, file_rm, dir_docs): \"\"\" Make the home file (index.md) Make the index.md file from the README. \"\"\" # first check if index exists dir_docs_out = Path(dir_prj) / dir_docs path_index = dir_docs_out / self._index_name # if not exist if not path_index.exists(): # create empty file if not use_rm: with open(path_index, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(\"Coming soon...\") return # if exist else: # leave alone if not use_rm: return # ---------------------------------------------------------------------- # make home page # NB: just copy readme.md to index.md if use_rm: # path to files readme_file = Path(dir_prj) / file_rm # read input file text = \"\" with open(readme_file, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # write file with open(path_index, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) # -------------------------------------------------------------------------- # Make the api files # -------------------------------------------------------------------------- def _make_api(self, dir_prj, use_api, lst_api_in, dir_api_out, dir_docs): \"\"\" Make the api files Make the documents using the specified parameters. \"\"\" # sanity check if not dir_api_out: return # find api dir dir_prj = Path(dir_prj) dir_docs_out = dir_prj / dir_docs dir_api_out = dir_docs_out / dir_api_out # nuke it if it exists and we changed out mind if not use_api and dir_api_out.exists(): shutil.rmtree(dir_api_out) return # ---------------------------------------------------------------------- # gather list of full paths to .py files files_out = [] for item in lst_api_in: dir_api = dir_prj / item # NB: root is a full path, dirs and files are relative to root for root, _root_dirs, root_files in dir_api.walk(): # convert files into Paths files = [root / f for f in root_files] files = [ f for f in files if f.suffix.lower() == self.S_EXT_IN.lower() ] # for each file item for item in files: files_out.append(item) # ---------------------------------------------------------------------- # make structure # nuke / remake the api folder if dir_api_out.exists(): # delete and recreate dir shutil.rmtree(dir_api_out) dir_api_out.mkdir(parents=True) # for each py file for f in files_out: # make a parent folder in docs (goes in nav bar) # NB: basically we find every .py file and get its path relative to # project dir # then we make a folder with the same relative path, but rel to docs # dir path_rel = f.relative_to(dir_prj) path_doc = dir_api_out / path_rel.parent path_doc.mkdir(parents=True, exist_ok=True) # create a default file # NB: just swap \".py\" ext for \".md\" file_md = path_doc / Path(str(f.stem) + self.S_EXT_OUT) # fix rel path into package dot notation s_parts = \".\".join(path_rel.parts) if s_parts.endswith(self.S_EXT_IN): s_parts = s_parts.removesuffix(self.S_EXT_IN) # format contents of file file_fmt = self.S_DEF_FILE.format(f.name, s_parts) with open(file_md, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(file_fmt)","title":"CNMkDocs"},{"location":"API/cnlib/cnmkdocs/#cnlib.cnmkdocs.CNMkDocs.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in cnlib/cnmkdocs.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # NB: DO NOT CHANGE!!! self._index_name = \"index.md\" self._dir_img = \"img\"","title":"__init__"},{"location":"API/cnlib/cnmkdocs/#cnlib.cnmkdocs.CNMkDocs.build_docs","text":"Bake docs using mkdocs Updates and deploys docs using mkdocs. Source code in cnlib/cnmkdocs.py def build_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # build docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_BUILD.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e","title":"build_docs"},{"location":"API/cnlib/cnmkdocs/#cnlib.cnmkdocs.CNMkDocs.deploy_docs","text":"Bake docs using mkdocs Updates and deploys docs using mkdocs. Source code in cnlib/cnmkdocs.py def deploy_docs(self, p_dir_pp_venv, p_dir_prj): \"\"\" Bake docs using mkdocs Raises: cnlib.cnfunctions.CNRunError if bake fails Updates and deploys docs using mkdocs. \"\"\" # ---------------------------------------------------------------------- # deploy docs # format cmd using pdoc template dir, output dir, and start dir cmd_docs = self.S_CMD_DOC_DEPLOY.format(p_dir_pp_venv, p_dir_prj) # the command to run mkdocs try: cp = F.run(cmd_docs, shell=True, capture_output=True) return cp except F.CNRunError as e: raise e","title":"deploy_docs"},{"location":"API/cnlib/cnmkdocs/#cnlib.cnmkdocs.CNMkDocs.make_docs","text":"Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description Source code in cnlib/cnmkdocs.py def make_docs( self, dir_prj, dir_docs, use_rm=False, use_api=False, lst_api_in=None, file_rm=None, dir_api_out=None, dir_img=None, ): \"\"\" Docstring for make_docs :param self: Description :param dir_prj: Description :param use_rm: Description :param use_api: Description :param lst_api_in: Description :param file_rm: Description :param dir_api_out: Description :param dir_img: Description \"\"\" # NB: mutable lists are only set once, passing an empty list does # NUSSING!!! # so we pass None to make sure the internal list gets reset if not lst_api_in: lst_api_in = [] # ---------------------------------------------------------------------- # check docs dir for exist # find docs dir dir_docs = Path(dir_prj) / dir_docs # no docs folder in template if not dir_docs.exists(): # make dir dir_docs.mkdir(parents=True) # make img dir # NB: the name of this dir is hard-coded in mkdocs (AFAIK) # it is used exclusively to serve the favicon.ico # paths to readme images, etc, can use a different dir img_dir = dir_docs / self._dir_img img_dir.mkdir(parents=True) # ---------------------------------------------------------------------- # make index # make empty or from readme or don't touch self._make_index(dir_prj, use_rm, file_rm, dir_docs) # ---------------------------------------------------------------------- # make api # make new api or delete old self._make_api(dir_prj, use_api, lst_api_in, dir_api_out, dir_docs) # ---------------------------------------------------------------------- # make img dir # dir_img is source (from project main) if dir_img: # make new img dir or combine dir_img_src = Path(dir_prj) / dir_img if dir_img_src.exists(): dir_img_dst = dir_docs / dir_img shutil.copytree(dir_img_src, dir_img_dst, dirs_exist_ok=True)","title":"make_docs"},{"location":"API/cnlib/cnpot/","text":"cnpot.py Run GNU gettext tools to create i18n files for a project This class converts all marked strings in source files to i18n versions using xgettext, and creates .pot files in the locale directory. It also uses msgfmt to convert .po files to .mo files. The class can handle all xgettext's supported file types by using each language name as the key for a list of file extensions in a dictionary. Note that the word \"language\" here can refer either to the computer language of the input file (ie. \"Python\", \"Glade\") or the written language of the output file (ie. \"English\", \"Spanish\"). I have tried to disambiguate this by using \"clang(s)\" to refer to the former, and \"wlang(s)\" to refer to the latter. CNPotPy A class to handle making the different I18N files needed for a Python project Methods: Name Description main Run the program and make or update the files make_desktop Localize the desktop file using all available wlangs This class provides methods to create .pot, .po, .mo, and .desktop files for internationalizing a Python or PyGObject project. Source code in cnlib/cnpot.py class CNPotPy: \"\"\" A class to handle making the different I18N files needed for a Python project Methods: main: Run the program and make or update the files make_desktop: Localize the desktop file using all available wlangs This class provides methods to create .pot, .po, .mo, and .desktop files for internationalizing a Python or PyGObject project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # default encoding for .pot and .po files S_ENCODING = \"UTF-8\" # this is the default subdir for GNU S_DIR_LC = \"LC_MESSAGES\" # the file to store all wlang/domain names for .desktop files S_FILE_LINGUAS = \"LINGUAS\" # default file extensions S_EXT_POT = \".pot\" S_EXT_PO = \".po\" S_EXT_MO = \".mo\" # shell commands to make po/mo # NB: format params are file_po and pot_file S_CMD_MERGE_POS = \"msgmerge --update {} {} --backup=none\" # NB: format params are mo_file and wlang_po S_CMD_MAKE_MOS = \"msgfmt -o {} {}\" # NB: format params are po dir, template file, and output file S_CMD_DESK = \"msgfmt --desktop -d {} --template={} -o {} \" # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # header regexes R_TITLE_SCH = r\"# SOME DESCRIPTIVE TITLE.\" R_TITLE_REP = r\"# {} translation template\" R_COPY_SCH = ( r\"(# Copyright \\(C\\) )(YEAR)( )(THE PACKAGE'S COPYRIGHT HOLDER)\" ) R_COPY_REP = r\"\\g<1>{}\\g<3>{}\" R_EMAIL_SCH = r\"(# FIRST AUTHOR )(<EMAIL@ADDRESS>)(, )(YEAR)\" R_EMAIL_REP = r\"\\g<1>{}\\g<3>{}\" R_CHAR_SCH = r\"(\\\"Content-Type: text/plain; charset=)(CHARSET)(.*)\" R_CHAR_REP = r\"\\g<1>{}\\g<3>\" R_VER_SCH = r\"^(\\\"Project-Id-Version: .*? )([^\\n]*)(\\\\n\\\")$\" R_VER_REP = r\"\\g<1>{}\\g<3>\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__( self, # header str_domain, str_version, str_author, str_email, # base prj dir dir_prj, # in list_src, # out dir_pot, dir_po, dir_locale, # optional in str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING, ): \"\"\" Initialize the new object Args: str_domain: The name of the domain (base name) for output files This creates files like \"<str_domain>.pot\", \"<str_domain>.po\", and \"<str_domain>.mo\", and is used in the .py scripts to bind a domain to a locale folder str_version: Version info to use in .pot/.po header str_author: Author name to use in .pot/.po header str_email: Email to use in .pot/.po header dir_prj: The main project dir, used for relative paths list_src: Where to look for input files dir_pot: Directory to place master .pot file dir_po: Directory to place .po file dir_locale: Directory to place .mo files str_tag: Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. dict_clangs: The dictionary of file extensions to scan for each clang (default: None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). list_wlangs: A list of supported languages to ensure a complete file structure in the project dir (default: None) charset: the charset to use as the default in the .pot file, and any initial .po files created (default: \"UTF-8\") An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # set header info self._str_domain = str_domain self._str_version = str_version self._str_author = str_author self._str_email = str_email # set base props self._dir_prj = Path(dir_prj) # fix up in props if list_src is None: list_src = [] self._list_src = list_src # set out props self._dir_pot = Path(dir_pot) if not self._dir_pot.is_absolute(): self._dir_pot = self._dir_prj / dir_pot self._dir_po = Path(dir_po) if not self._dir_po.is_absolute(): self._dir_po = self._dir_prj / dir_po self._dir_locale = Path(dir_locale) if not self._dir_locale.is_absolute(): self._dir_locale = self._dir_prj / dir_locale # set optional in props # set comment tag if str_tag is None: str_tag = \"\" self._str_tag = str_tag # fix up dict_clangs if dict_clangs is None: dict_clangs = {} self._dict_clangs = dict(dict_clangs) # fix up list_wlangs if list_wlangs is None: list_wlangs = [] self._list_wlangs = list(list_wlangs) # fix up charset if charset is None: charset = self.S_ENCODING self._charset = charset # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Run the program and make or update the files # -------------------------------------------------------------------------- def main(self): \"\"\" Run the program and make or update the files Raises: cnlib.cnfunctions.CNRunError if anything fails Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. \"\"\" # ---------------------------------------------------------------------- # do the steps # make sure all necessary dirs exist self._make_wlang_dirs() try: self._make_pot() self._make_pos() self._make_mos() except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Localize the desktop file using all available wlangs # -------------------------------------------------------------------------- def make_desktop(self, dt_template, dt_out): \"\"\" Localize the desktop file using all available wlangs Args: dt_template: File containing the default information to include in the desktop file This is the file that pymaker/pybaker modifies using metadata. dt_out: Location of the i18n'ed desktop file This is the file that will be distributed with your app. Raises: cnlib.cnfunctions.CNRunError if the make fails Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. \"\"\" # fix params to abs paths dt_template = Path(dt_template) if not dt_template.is_absolute(): dt_template = self._dir_prj / dt_template dt_out = Path(dt_out) if not dt_out.is_absolute(): dt_out = self._dir_prj / dt_out # check if template exists if dt_template.exists(): # build the command as a string cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out) # run the command try: F.run(cmd) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Create a .pot file in the locale folder # -------------------------------------------------------------------------- def _make_pot(self): \"\"\" Create a .pot file in the pot folder Raises: cnlib.cnfunctions.CNRunError if the make fails Parses the files for each clang, creating a unified .pot file, which is placed in \"<dir_pot>/<str_domain>.pot\". \"\"\" # ok so this is a tricky situation. here are the possible scenarios: # 1. create a new, fresh .pot that has never existed before # 2. add / edit / remove files to / from a .pot file we have already # created # 3. add / edit / remove strings to / from a .pot file we have already # created # 4. add / edit / remove clang types to / from a .pot file we have # already created # 6. etc., etc., etc # how do we do all this (at least in the context of a .pot file)? # the simplest answer would seem to be: # delete the .pot (if it exists) and start over fresh every time # BUT! we need to use the -j (join) flag in order to allow multiple # clangs to be combined into one .pot file # the solution i have found is: # delete the existing .pot file (if it exists) # create a new, empty .pot file (if it does not exist, which it # shouldn't, race conditions be damned... Python file operations are # atomic, right? RIGHT???) # run every clang through xgettext, joining it with the previous file # until we have a .pot file that contains every string (and only the # strings) in dict_clangs # step 3: PROFIT! (hahaha that joke never gets old...) # get path to pot file file_pot = self._dir_pot / f\"{self._str_domain}{self.S_EXT_POT}\" # delete the existing .pot file (if it exists) file_pot.unlink(missing_ok=True) # create a new, empty .pot file if it does not exist # NB: this allow us to use the -j flag without error (which would # happen if the current file to join does not exist) file_pot.parent.mkdir(parents=True, exist_ok=True) file_pot.touch(exist_ok=True) # get all paths for this domain # NB: or if no src list specified, scan ALL files clangs_paths = self._get_paths_for_clangs() # for each clang name / list of clang files for clang_name, clang_files in clangs_paths.items(): # sanity check if len(clang_files) == 0: continue # get initial cmd cmd = ( f\"cd {self._dir_prj}; \" \"xgettext \" # add any comments above string (or msgctxt in ui files) # NB: check that all files have appropriate contexts/comments # NB: also, no space after -c? weird right? f\"-c{self._str_tag} \" # fix some header values (the rest should be fixed in # _fix_pot_header) # copyright # NB: if blank, file is public domain # if not included, file is under same license as _str_appname # \"--copyright-holder \"\" \" # version # | name | version | Project-Id-Version # ----------------------------------- # | 0 | 0 | PACKAGE VERSION # | 0 | 1 | PACKAGE VERSION # | 1 | 0 | self._str_domain # | 1 | 1 | self._str_domain self._str_version f\"--package-name {self._str_domain} \" f\"--package-version {self._str_version} \" # author email f\"--msgid-bugs-address {self._str_email} \" # sort entries by file \"-F \" # don't add location info (hide path to source) # \"--no-location \" # append existing file # NB: this is the key to running xgettext multiple times for # one domain # this allows us to set the -L option for different file types # and still end up with one unified .pot file \"-j \" # final name of output file # NB: note that you can fiddle with the -o, -d, and -p options # here, but i find it's just better to use an abs path to the # output file f\"-o {file_pot} \" # add -L for specific exts f\"-L {clang_name} \" ) # add all input files paths = [f'\"{item}\" ' for item in clang_files] j_paths = \"\".join(paths) cmd += j_paths # do the final command try: F.run(cmd, shell=True) except F.CNRunError as e: raise e # fix CHARSET in pot self._fix_pot_header(file_pot) # -------------------------------------------------------------------------- # Merge any .po files in the pos folder with existing .po files # -------------------------------------------------------------------------- def _make_pos(self): \"\"\" Create .po files in the po folder or merge any updated .pot files with existing .po files Raises: cnlib.cnfunctions.CNRunError if the make fails Whenever a new .pot file is generated using make_pot, this method will produce a new .po file for each wlang that contains the difference between the new .pot file and the existing .po file. This new .po file should be sent to the translator for each wlang. Then when the translator sends back the translated .po file, place it in the appropriate <dir_po>/<wlang> dir. Then run pybaker to create a new .mo file. \"\"\" # for each wlang in the po folder for wlang in self._list_wlangs: # get the pot file we made in the last step file_pot = self._dir_pot / f\"{self._str_domain}{self.S_EXT_POT}\" # create or update the .po file file_po = ( self._dir_po / f\"{wlang}/{self._str_domain}{self.S_EXT_PO}\" ) file_po.parent.mkdir(parents=True, exist_ok=True) if not file_po.exists(): # no po file, copy pot shutil.copy(file_pot, file_po) continue # update existing po file using latest pot cmd = self.S_CMD_MERGE_POS.format(file_po, file_pot) try: F.run(cmd, capture_output=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Create .mo files for all .po files in the locale folder # -------------------------------------------------------------------------- def _make_mos(self): \"\"\" Create .mo files for all .po files in the locale folder Raises: cnlib.cnfunctions.CNRunError if the make fails Makes all the required .mo files for all the .po files in the locale dir \"\"\" # get all wlangs to output glob_po = f\"**/*{self.S_EXT_PO}\" list_pos = list(self._dir_po.glob(glob_po)) # for each wlang for file_po in list_pos: # get wlang name wlang = file_po.parent.name # en, etc # get .mo file (output) mo_dir = self._dir_locale / wlang / self.S_DIR_LC mo_dir.mkdir(parents=True, exist_ok=True) mo_file = mo_dir / f\"{self._str_domain}{self.S_EXT_MO}\" # do the command cmd = self.S_CMD_MAKE_MOS.format(mo_file, file_po) try: F.run(cmd) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Make a list of all supported written language directories # -------------------------------------------------------------------------- def _make_wlang_dirs(self): \"\"\" Make a list of all supported written language directories This writes the LINGUAS file, which is used for i18n'ing a .desktop file. \"\"\" # ---------------------------------------------------------------------- # make the main dirs self._dir_pot.mkdir(parents=True, exist_ok=True) self._dir_po.mkdir(parents=True, exist_ok=True) self._dir_locale.mkdir(parents=True, exist_ok=True) # make the LC dirs for wlang in self._list_wlangs: # make the locale/lang/LC_MESSAGES dir mo_dir = self._dir_locale / wlang / self.S_DIR_LC mo_dir.mkdir(parents=True, exist_ok=True) # make LINGUAS file linguas = \"\" for wlang in self._list_wlangs: # add each wlang to LINGUAS file linguas += f\"{wlang}/{self._str_domain} \" # write the LINGUAS file linguas_path = self._dir_po / self.S_FILE_LINGUAS with open(linguas_path, \"w\", encoding=self.S_ENCODING) as f: f.write(linguas) # -------------------------------------------------------------------------- # Scan the source dirs for files with certain extensions # -------------------------------------------------------------------------- def _get_paths_for_clangs(self): \"\"\" Scan the source dirs for files with certain extensions Returns: A dictionary containing file paths to source files This method uses the list_src list to convert the dict_clangs dictionary: { \"Python\": [\".py\"], \"Glade\": [\".ui\", \".glade\"], \"Desktop\": [\".desktop\"], } into a dictionary of file paths to scan for each clang: { \"Python\": [<str>, ...], \"Glade\": [<str>, ...], \"Desktop\": [<str>, ...], } so they can be passed to xgettext. \"\"\" # the dict to return dict_res = {} # ---------------------------------------------------------------------- # for each item in list_src for place in self._list_src: # resolve place p_place = self._dir_prj / place # check if dir if p_place.is_dir(): # for each clang name / list of exts for clang, exts in self._dict_clangs.items(): # the new list of files list_clang = [] # for each clang ext for ext in exts: # get matching files and add to list res = list( p_place.glob(\"**/*\" + ext, case_sensitive=False) ) list_clang.extend(res) # update result lang's val # NB: xgettext does not handle Paths, only strs list_clang = [str(item) for item in list_clang] list_old = dict_res.get(clang, []) list_old.extend(list_clang) dict_res[clang] = list_old # src item is file else: # get item suffix (including dot) ext_place = p_place.suffix # find lang from suffix for clang, exts in self._dict_clangs.items(): # Python, [\".py\"] # if this item belongs to this clang if ext_place in exts: # update result lang's val # NB: xgettext does not handle Paths, only strs list_old = dict_res.get(clang, []) list_old.extend([str(p_place)]) dict_res[clang] = list_old break # ---------------------------------------------------------------------- # return the result return dict_res # -------------------------------------------------------------------------- # Set the header values for the pot which will carry over to each po # -------------------------------------------------------------------------- def _fix_pot_header(self, file_pot): \"\"\" Set the header values for the pot which will carry over to each po Args: file_pot: the path object representing the pot file to fix Fix the charset in the pot file to a known value so that msgfmt does not complain. The charset for an individual file can be set by the translator. This is just to keep the compiler from complaining, and also aids in testing when no editing is done. \"\"\" # open file and get contents with open(file_pot, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # replace short description str_pattern = self.R_TITLE_SCH str_rep = self.R_TITLE_REP.format(self._str_domain) text = re.sub(str_pattern, str_rep, text) # replace copyright str_pattern = self.R_COPY_SCH year = date.today().year str_rep = self.R_COPY_REP.format(year, self._str_author) text = re.sub(str_pattern, str_rep, text) # replace author's email str_pattern = self.R_EMAIL_SCH email = self._str_email year = date.today().year str_rep = self.R_EMAIL_REP.format(email, year) text = re.sub(str_pattern, str_rep, text) # NB: if the specific phrase \"CHARSET\" is not found, nothing will be # changed str_pattern = self.R_CHAR_SCH str_rep = self.R_CHAR_REP.format(self._charset) text = re.sub(str_pattern, str_rep, text, flags=re.M) # save file with open(file_pot, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text) __init__(str_domain, str_version, str_author, str_email, dir_prj, list_src, dir_pot, dir_po, dir_locale, str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING) Initialize the new object Parameters: Name Type Description Default str_domain The name of the domain (base name) for output files This creates files like \" .pot\", \" .po\", and \" .mo\", and is used in the .py scripts to bind a domain to a locale folder required str_version Version info to use in .pot/.po header required str_author Author name to use in .pot/.po header required str_email Email to use in .pot/.po header required dir_prj The main project dir, used for relative paths required list_src Where to look for input files required dir_pot Directory to place master .pot file required dir_po Directory to place .po file required dir_locale Directory to place .mo files required str_tag Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. None dict_clangs The dictionary of file extensions to scan for each None clang default None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). required list_wlangs A list of supported languages to ensure a complete None file structure in the project dir (default None) required charset the charset to use as the default in the .pot file, and S_ENCODING any initial .po files created (default \"UTF-8\") required An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. Source code in cnlib/cnpot.py def __init__( self, # header str_domain, str_version, str_author, str_email, # base prj dir dir_prj, # in list_src, # out dir_pot, dir_po, dir_locale, # optional in str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING, ): \"\"\" Initialize the new object Args: str_domain: The name of the domain (base name) for output files This creates files like \"<str_domain>.pot\", \"<str_domain>.po\", and \"<str_domain>.mo\", and is used in the .py scripts to bind a domain to a locale folder str_version: Version info to use in .pot/.po header str_author: Author name to use in .pot/.po header str_email: Email to use in .pot/.po header dir_prj: The main project dir, used for relative paths list_src: Where to look for input files dir_pot: Directory to place master .pot file dir_po: Directory to place .po file dir_locale: Directory to place .mo files str_tag: Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. dict_clangs: The dictionary of file extensions to scan for each clang (default: None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). list_wlangs: A list of supported languages to ensure a complete file structure in the project dir (default: None) charset: the charset to use as the default in the .pot file, and any initial .po files created (default: \"UTF-8\") An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # set header info self._str_domain = str_domain self._str_version = str_version self._str_author = str_author self._str_email = str_email # set base props self._dir_prj = Path(dir_prj) # fix up in props if list_src is None: list_src = [] self._list_src = list_src # set out props self._dir_pot = Path(dir_pot) if not self._dir_pot.is_absolute(): self._dir_pot = self._dir_prj / dir_pot self._dir_po = Path(dir_po) if not self._dir_po.is_absolute(): self._dir_po = self._dir_prj / dir_po self._dir_locale = Path(dir_locale) if not self._dir_locale.is_absolute(): self._dir_locale = self._dir_prj / dir_locale # set optional in props # set comment tag if str_tag is None: str_tag = \"\" self._str_tag = str_tag # fix up dict_clangs if dict_clangs is None: dict_clangs = {} self._dict_clangs = dict(dict_clangs) # fix up list_wlangs if list_wlangs is None: list_wlangs = [] self._list_wlangs = list(list_wlangs) # fix up charset if charset is None: charset = self.S_ENCODING self._charset = charset main() Run the program and make or update the files Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. Source code in cnlib/cnpot.py def main(self): \"\"\" Run the program and make or update the files Raises: cnlib.cnfunctions.CNRunError if anything fails Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. \"\"\" # ---------------------------------------------------------------------- # do the steps # make sure all necessary dirs exist self._make_wlang_dirs() try: self._make_pot() self._make_pos() self._make_mos() except F.CNRunError as e: raise e make_desktop(dt_template, dt_out) Localize the desktop file using all available wlangs Parameters: Name Type Description Default dt_template File containing the default information to include in required dt_out Location of the i18n'ed desktop file This is the file that will be distributed with your app. required Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. Source code in cnlib/cnpot.py def make_desktop(self, dt_template, dt_out): \"\"\" Localize the desktop file using all available wlangs Args: dt_template: File containing the default information to include in the desktop file This is the file that pymaker/pybaker modifies using metadata. dt_out: Location of the i18n'ed desktop file This is the file that will be distributed with your app. Raises: cnlib.cnfunctions.CNRunError if the make fails Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. \"\"\" # fix params to abs paths dt_template = Path(dt_template) if not dt_template.is_absolute(): dt_template = self._dir_prj / dt_template dt_out = Path(dt_out) if not dt_out.is_absolute(): dt_out = self._dir_prj / dt_out # check if template exists if dt_template.exists(): # build the command as a string cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out) # run the command try: F.run(cmd) except F.CNRunError as e: raise e","title":"cnpot.py"},{"location":"API/cnlib/cnpot/#cnpotpy","text":"Run GNU gettext tools to create i18n files for a project This class converts all marked strings in source files to i18n versions using xgettext, and creates .pot files in the locale directory. It also uses msgfmt to convert .po files to .mo files. The class can handle all xgettext's supported file types by using each language name as the key for a list of file extensions in a dictionary. Note that the word \"language\" here can refer either to the computer language of the input file (ie. \"Python\", \"Glade\") or the written language of the output file (ie. \"English\", \"Spanish\"). I have tried to disambiguate this by using \"clang(s)\" to refer to the former, and \"wlang(s)\" to refer to the latter.","title":"cnpot.py"},{"location":"API/cnlib/cnpot/#cnlib.cnpot.CNPotPy","text":"A class to handle making the different I18N files needed for a Python project Methods: Name Description main Run the program and make or update the files make_desktop Localize the desktop file using all available wlangs This class provides methods to create .pot, .po, .mo, and .desktop files for internationalizing a Python or PyGObject project. Source code in cnlib/cnpot.py class CNPotPy: \"\"\" A class to handle making the different I18N files needed for a Python project Methods: main: Run the program and make or update the files make_desktop: Localize the desktop file using all available wlangs This class provides methods to create .pot, .po, .mo, and .desktop files for internationalizing a Python or PyGObject project. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # default encoding for .pot and .po files S_ENCODING = \"UTF-8\" # this is the default subdir for GNU S_DIR_LC = \"LC_MESSAGES\" # the file to store all wlang/domain names for .desktop files S_FILE_LINGUAS = \"LINGUAS\" # default file extensions S_EXT_POT = \".pot\" S_EXT_PO = \".po\" S_EXT_MO = \".mo\" # shell commands to make po/mo # NB: format params are file_po and pot_file S_CMD_MERGE_POS = \"msgmerge --update {} {} --backup=none\" # NB: format params are mo_file and wlang_po S_CMD_MAKE_MOS = \"msgfmt -o {} {}\" # NB: format params are po dir, template file, and output file S_CMD_DESK = \"msgfmt --desktop -d {} --template={} -o {} \" # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # header regexes R_TITLE_SCH = r\"# SOME DESCRIPTIVE TITLE.\" R_TITLE_REP = r\"# {} translation template\" R_COPY_SCH = ( r\"(# Copyright \\(C\\) )(YEAR)( )(THE PACKAGE'S COPYRIGHT HOLDER)\" ) R_COPY_REP = r\"\\g<1>{}\\g<3>{}\" R_EMAIL_SCH = r\"(# FIRST AUTHOR )(<EMAIL@ADDRESS>)(, )(YEAR)\" R_EMAIL_REP = r\"\\g<1>{}\\g<3>{}\" R_CHAR_SCH = r\"(\\\"Content-Type: text/plain; charset=)(CHARSET)(.*)\" R_CHAR_REP = r\"\\g<1>{}\\g<3>\" R_VER_SCH = r\"^(\\\"Project-Id-Version: .*? )([^\\n]*)(\\\\n\\\")$\" R_VER_REP = r\"\\g<1>{}\\g<3>\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__( self, # header str_domain, str_version, str_author, str_email, # base prj dir dir_prj, # in list_src, # out dir_pot, dir_po, dir_locale, # optional in str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING, ): \"\"\" Initialize the new object Args: str_domain: The name of the domain (base name) for output files This creates files like \"<str_domain>.pot\", \"<str_domain>.po\", and \"<str_domain>.mo\", and is used in the .py scripts to bind a domain to a locale folder str_version: Version info to use in .pot/.po header str_author: Author name to use in .pot/.po header str_email: Email to use in .pot/.po header dir_prj: The main project dir, used for relative paths list_src: Where to look for input files dir_pot: Directory to place master .pot file dir_po: Directory to place .po file dir_locale: Directory to place .mo files str_tag: Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. dict_clangs: The dictionary of file extensions to scan for each clang (default: None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). list_wlangs: A list of supported languages to ensure a complete file structure in the project dir (default: None) charset: the charset to use as the default in the .pot file, and any initial .po files created (default: \"UTF-8\") An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # set header info self._str_domain = str_domain self._str_version = str_version self._str_author = str_author self._str_email = str_email # set base props self._dir_prj = Path(dir_prj) # fix up in props if list_src is None: list_src = [] self._list_src = list_src # set out props self._dir_pot = Path(dir_pot) if not self._dir_pot.is_absolute(): self._dir_pot = self._dir_prj / dir_pot self._dir_po = Path(dir_po) if not self._dir_po.is_absolute(): self._dir_po = self._dir_prj / dir_po self._dir_locale = Path(dir_locale) if not self._dir_locale.is_absolute(): self._dir_locale = self._dir_prj / dir_locale # set optional in props # set comment tag if str_tag is None: str_tag = \"\" self._str_tag = str_tag # fix up dict_clangs if dict_clangs is None: dict_clangs = {} self._dict_clangs = dict(dict_clangs) # fix up list_wlangs if list_wlangs is None: list_wlangs = [] self._list_wlangs = list(list_wlangs) # fix up charset if charset is None: charset = self.S_ENCODING self._charset = charset # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Run the program and make or update the files # -------------------------------------------------------------------------- def main(self): \"\"\" Run the program and make or update the files Raises: cnlib.cnfunctions.CNRunError if anything fails Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. \"\"\" # ---------------------------------------------------------------------- # do the steps # make sure all necessary dirs exist self._make_wlang_dirs() try: self._make_pot() self._make_pos() self._make_mos() except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Localize the desktop file using all available wlangs # -------------------------------------------------------------------------- def make_desktop(self, dt_template, dt_out): \"\"\" Localize the desktop file using all available wlangs Args: dt_template: File containing the default information to include in the desktop file This is the file that pymaker/pybaker modifies using metadata. dt_out: Location of the i18n'ed desktop file This is the file that will be distributed with your app. Raises: cnlib.cnfunctions.CNRunError if the make fails Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. \"\"\" # fix params to abs paths dt_template = Path(dt_template) if not dt_template.is_absolute(): dt_template = self._dir_prj / dt_template dt_out = Path(dt_out) if not dt_out.is_absolute(): dt_out = self._dir_prj / dt_out # check if template exists if dt_template.exists(): # build the command as a string cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out) # run the command try: F.run(cmd) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Create a .pot file in the locale folder # -------------------------------------------------------------------------- def _make_pot(self): \"\"\" Create a .pot file in the pot folder Raises: cnlib.cnfunctions.CNRunError if the make fails Parses the files for each clang, creating a unified .pot file, which is placed in \"<dir_pot>/<str_domain>.pot\". \"\"\" # ok so this is a tricky situation. here are the possible scenarios: # 1. create a new, fresh .pot that has never existed before # 2. add / edit / remove files to / from a .pot file we have already # created # 3. add / edit / remove strings to / from a .pot file we have already # created # 4. add / edit / remove clang types to / from a .pot file we have # already created # 6. etc., etc., etc # how do we do all this (at least in the context of a .pot file)? # the simplest answer would seem to be: # delete the .pot (if it exists) and start over fresh every time # BUT! we need to use the -j (join) flag in order to allow multiple # clangs to be combined into one .pot file # the solution i have found is: # delete the existing .pot file (if it exists) # create a new, empty .pot file (if it does not exist, which it # shouldn't, race conditions be damned... Python file operations are # atomic, right? RIGHT???) # run every clang through xgettext, joining it with the previous file # until we have a .pot file that contains every string (and only the # strings) in dict_clangs # step 3: PROFIT! (hahaha that joke never gets old...) # get path to pot file file_pot = self._dir_pot / f\"{self._str_domain}{self.S_EXT_POT}\" # delete the existing .pot file (if it exists) file_pot.unlink(missing_ok=True) # create a new, empty .pot file if it does not exist # NB: this allow us to use the -j flag without error (which would # happen if the current file to join does not exist) file_pot.parent.mkdir(parents=True, exist_ok=True) file_pot.touch(exist_ok=True) # get all paths for this domain # NB: or if no src list specified, scan ALL files clangs_paths = self._get_paths_for_clangs() # for each clang name / list of clang files for clang_name, clang_files in clangs_paths.items(): # sanity check if len(clang_files) == 0: continue # get initial cmd cmd = ( f\"cd {self._dir_prj}; \" \"xgettext \" # add any comments above string (or msgctxt in ui files) # NB: check that all files have appropriate contexts/comments # NB: also, no space after -c? weird right? f\"-c{self._str_tag} \" # fix some header values (the rest should be fixed in # _fix_pot_header) # copyright # NB: if blank, file is public domain # if not included, file is under same license as _str_appname # \"--copyright-holder \"\" \" # version # | name | version | Project-Id-Version # ----------------------------------- # | 0 | 0 | PACKAGE VERSION # | 0 | 1 | PACKAGE VERSION # | 1 | 0 | self._str_domain # | 1 | 1 | self._str_domain self._str_version f\"--package-name {self._str_domain} \" f\"--package-version {self._str_version} \" # author email f\"--msgid-bugs-address {self._str_email} \" # sort entries by file \"-F \" # don't add location info (hide path to source) # \"--no-location \" # append existing file # NB: this is the key to running xgettext multiple times for # one domain # this allows us to set the -L option for different file types # and still end up with one unified .pot file \"-j \" # final name of output file # NB: note that you can fiddle with the -o, -d, and -p options # here, but i find it's just better to use an abs path to the # output file f\"-o {file_pot} \" # add -L for specific exts f\"-L {clang_name} \" ) # add all input files paths = [f'\"{item}\" ' for item in clang_files] j_paths = \"\".join(paths) cmd += j_paths # do the final command try: F.run(cmd, shell=True) except F.CNRunError as e: raise e # fix CHARSET in pot self._fix_pot_header(file_pot) # -------------------------------------------------------------------------- # Merge any .po files in the pos folder with existing .po files # -------------------------------------------------------------------------- def _make_pos(self): \"\"\" Create .po files in the po folder or merge any updated .pot files with existing .po files Raises: cnlib.cnfunctions.CNRunError if the make fails Whenever a new .pot file is generated using make_pot, this method will produce a new .po file for each wlang that contains the difference between the new .pot file and the existing .po file. This new .po file should be sent to the translator for each wlang. Then when the translator sends back the translated .po file, place it in the appropriate <dir_po>/<wlang> dir. Then run pybaker to create a new .mo file. \"\"\" # for each wlang in the po folder for wlang in self._list_wlangs: # get the pot file we made in the last step file_pot = self._dir_pot / f\"{self._str_domain}{self.S_EXT_POT}\" # create or update the .po file file_po = ( self._dir_po / f\"{wlang}/{self._str_domain}{self.S_EXT_PO}\" ) file_po.parent.mkdir(parents=True, exist_ok=True) if not file_po.exists(): # no po file, copy pot shutil.copy(file_pot, file_po) continue # update existing po file using latest pot cmd = self.S_CMD_MERGE_POS.format(file_po, file_pot) try: F.run(cmd, capture_output=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Create .mo files for all .po files in the locale folder # -------------------------------------------------------------------------- def _make_mos(self): \"\"\" Create .mo files for all .po files in the locale folder Raises: cnlib.cnfunctions.CNRunError if the make fails Makes all the required .mo files for all the .po files in the locale dir \"\"\" # get all wlangs to output glob_po = f\"**/*{self.S_EXT_PO}\" list_pos = list(self._dir_po.glob(glob_po)) # for each wlang for file_po in list_pos: # get wlang name wlang = file_po.parent.name # en, etc # get .mo file (output) mo_dir = self._dir_locale / wlang / self.S_DIR_LC mo_dir.mkdir(parents=True, exist_ok=True) mo_file = mo_dir / f\"{self._str_domain}{self.S_EXT_MO}\" # do the command cmd = self.S_CMD_MAKE_MOS.format(mo_file, file_po) try: F.run(cmd) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Make a list of all supported written language directories # -------------------------------------------------------------------------- def _make_wlang_dirs(self): \"\"\" Make a list of all supported written language directories This writes the LINGUAS file, which is used for i18n'ing a .desktop file. \"\"\" # ---------------------------------------------------------------------- # make the main dirs self._dir_pot.mkdir(parents=True, exist_ok=True) self._dir_po.mkdir(parents=True, exist_ok=True) self._dir_locale.mkdir(parents=True, exist_ok=True) # make the LC dirs for wlang in self._list_wlangs: # make the locale/lang/LC_MESSAGES dir mo_dir = self._dir_locale / wlang / self.S_DIR_LC mo_dir.mkdir(parents=True, exist_ok=True) # make LINGUAS file linguas = \"\" for wlang in self._list_wlangs: # add each wlang to LINGUAS file linguas += f\"{wlang}/{self._str_domain} \" # write the LINGUAS file linguas_path = self._dir_po / self.S_FILE_LINGUAS with open(linguas_path, \"w\", encoding=self.S_ENCODING) as f: f.write(linguas) # -------------------------------------------------------------------------- # Scan the source dirs for files with certain extensions # -------------------------------------------------------------------------- def _get_paths_for_clangs(self): \"\"\" Scan the source dirs for files with certain extensions Returns: A dictionary containing file paths to source files This method uses the list_src list to convert the dict_clangs dictionary: { \"Python\": [\".py\"], \"Glade\": [\".ui\", \".glade\"], \"Desktop\": [\".desktop\"], } into a dictionary of file paths to scan for each clang: { \"Python\": [<str>, ...], \"Glade\": [<str>, ...], \"Desktop\": [<str>, ...], } so they can be passed to xgettext. \"\"\" # the dict to return dict_res = {} # ---------------------------------------------------------------------- # for each item in list_src for place in self._list_src: # resolve place p_place = self._dir_prj / place # check if dir if p_place.is_dir(): # for each clang name / list of exts for clang, exts in self._dict_clangs.items(): # the new list of files list_clang = [] # for each clang ext for ext in exts: # get matching files and add to list res = list( p_place.glob(\"**/*\" + ext, case_sensitive=False) ) list_clang.extend(res) # update result lang's val # NB: xgettext does not handle Paths, only strs list_clang = [str(item) for item in list_clang] list_old = dict_res.get(clang, []) list_old.extend(list_clang) dict_res[clang] = list_old # src item is file else: # get item suffix (including dot) ext_place = p_place.suffix # find lang from suffix for clang, exts in self._dict_clangs.items(): # Python, [\".py\"] # if this item belongs to this clang if ext_place in exts: # update result lang's val # NB: xgettext does not handle Paths, only strs list_old = dict_res.get(clang, []) list_old.extend([str(p_place)]) dict_res[clang] = list_old break # ---------------------------------------------------------------------- # return the result return dict_res # -------------------------------------------------------------------------- # Set the header values for the pot which will carry over to each po # -------------------------------------------------------------------------- def _fix_pot_header(self, file_pot): \"\"\" Set the header values for the pot which will carry over to each po Args: file_pot: the path object representing the pot file to fix Fix the charset in the pot file to a known value so that msgfmt does not complain. The charset for an individual file can be set by the translator. This is just to keep the compiler from complaining, and also aids in testing when no editing is done. \"\"\" # open file and get contents with open(file_pot, \"r\", encoding=self.S_ENCODING) as a_file: text = a_file.read() # replace short description str_pattern = self.R_TITLE_SCH str_rep = self.R_TITLE_REP.format(self._str_domain) text = re.sub(str_pattern, str_rep, text) # replace copyright str_pattern = self.R_COPY_SCH year = date.today().year str_rep = self.R_COPY_REP.format(year, self._str_author) text = re.sub(str_pattern, str_rep, text) # replace author's email str_pattern = self.R_EMAIL_SCH email = self._str_email year = date.today().year str_rep = self.R_EMAIL_REP.format(email, year) text = re.sub(str_pattern, str_rep, text) # NB: if the specific phrase \"CHARSET\" is not found, nothing will be # changed str_pattern = self.R_CHAR_SCH str_rep = self.R_CHAR_REP.format(self._charset) text = re.sub(str_pattern, str_rep, text, flags=re.M) # save file with open(file_pot, \"w\", encoding=self.S_ENCODING) as a_file: a_file.write(text)","title":"CNPotPy"},{"location":"API/cnlib/cnpot/#cnlib.cnpot.CNPotPy.__init__","text":"Initialize the new object Parameters: Name Type Description Default str_domain The name of the domain (base name) for output files This creates files like \" .pot\", \" .po\", and \" .mo\", and is used in the .py scripts to bind a domain to a locale folder required str_version Version info to use in .pot/.po header required str_author Author name to use in .pot/.po header required str_email Email to use in .pot/.po header required dir_prj The main project dir, used for relative paths required list_src Where to look for input files required dir_pot Directory to place master .pot file required dir_po Directory to place .po file required dir_locale Directory to place .mo files required str_tag Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. None dict_clangs The dictionary of file extensions to scan for each None clang default None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). required list_wlangs A list of supported languages to ensure a complete None file structure in the project dir (default None) required charset the charset to use as the default in the .pot file, and S_ENCODING any initial .po files created (default \"UTF-8\") required An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. Source code in cnlib/cnpot.py def __init__( self, # header str_domain, str_version, str_author, str_email, # base prj dir dir_prj, # in list_src, # out dir_pot, dir_po, dir_locale, # optional in str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING, ): \"\"\" Initialize the new object Args: str_domain: The name of the domain (base name) for output files This creates files like \"<str_domain>.pot\", \"<str_domain>.po\", and \"<str_domain>.mo\", and is used in the .py scripts to bind a domain to a locale folder str_version: Version info to use in .pot/.po header str_author: Author name to use in .pot/.po header str_email: Email to use in .pot/.po header dir_prj: The main project dir, used for relative paths list_src: Where to look for input files dir_pot: Directory to place master .pot file dir_po: Directory to place .po file dir_locale: Directory to place .mo files str_tag: Tag that starts a context comment (default: None) If this string is empty or None, all comments above an entry are included as context. dict_clangs: The dictionary of file extensions to scan for each clang (default: None) If ths dict is empty or None, all files will be scanned (this is generally considered a \"Very Bad Thing\"). list_wlangs: A list of supported languages to ensure a complete file structure in the project dir (default: None) charset: the charset to use as the default in the .pot file, and any initial .po files created (default: \"UTF-8\") An example format for the dict_clangs arg is: { \"Python\": [ \".py\", ], \"Glade\": [ \".ui\", \".glade\", ], \"Desktop\": [ \".desktop\" ], } An example format for list_wlangs is: [ \"en_US\", \"de_DE.ISO_88591\", \"es\", ] Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # set header info self._str_domain = str_domain self._str_version = str_version self._str_author = str_author self._str_email = str_email # set base props self._dir_prj = Path(dir_prj) # fix up in props if list_src is None: list_src = [] self._list_src = list_src # set out props self._dir_pot = Path(dir_pot) if not self._dir_pot.is_absolute(): self._dir_pot = self._dir_prj / dir_pot self._dir_po = Path(dir_po) if not self._dir_po.is_absolute(): self._dir_po = self._dir_prj / dir_po self._dir_locale = Path(dir_locale) if not self._dir_locale.is_absolute(): self._dir_locale = self._dir_prj / dir_locale # set optional in props # set comment tag if str_tag is None: str_tag = \"\" self._str_tag = str_tag # fix up dict_clangs if dict_clangs is None: dict_clangs = {} self._dict_clangs = dict(dict_clangs) # fix up list_wlangs if list_wlangs is None: list_wlangs = [] self._list_wlangs = list(list_wlangs) # fix up charset if charset is None: charset = self.S_ENCODING self._charset = charset","title":"__init__"},{"location":"API/cnlib/cnpot/#cnlib.cnpot.CNPotPy.main","text":"Run the program and make or update the files Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. Source code in cnlib/cnpot.py def main(self): \"\"\" Run the program and make or update the files Raises: cnlib.cnfunctions.CNRunError if anything fails Main method of the class, performing its steps. This method can (and should) be run, in Mayor Tweed's words, \"early and often\". You should run it every time a source file that contains i18n strings is added, edited, or deleted. The ideal scenario is to run it just before the repo is synced, so that the .pot file is synced. \"\"\" # ---------------------------------------------------------------------- # do the steps # make sure all necessary dirs exist self._make_wlang_dirs() try: self._make_pot() self._make_pos() self._make_mos() except F.CNRunError as e: raise e","title":"main"},{"location":"API/cnlib/cnpot/#cnlib.cnpot.CNPotPy.make_desktop","text":"Localize the desktop file using all available wlangs Parameters: Name Type Description Default dt_template File containing the default information to include in required dt_out Location of the i18n'ed desktop file This is the file that will be distributed with your app. required Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. Source code in cnlib/cnpot.py def make_desktop(self, dt_template, dt_out): \"\"\" Localize the desktop file using all available wlangs Args: dt_template: File containing the default information to include in the desktop file This is the file that pymaker/pybaker modifies using metadata. dt_out: Location of the i18n'ed desktop file This is the file that will be distributed with your app. Raises: cnlib.cnfunctions.CNRunError if the make fails Takes a template desktop file and applies all i18n'ed info from all .po files in the po folder and creates a final .desktop file. \"\"\" # fix params to abs paths dt_template = Path(dt_template) if not dt_template.is_absolute(): dt_template = self._dir_prj / dt_template dt_out = Path(dt_out) if not dt_out.is_absolute(): dt_out = self._dir_prj / dt_out # check if template exists if dt_template.exists(): # build the command as a string cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out) # run the command try: F.run(cmd) except F.CNRunError as e: raise e","title":"make_desktop"},{"location":"API/cnlib/cntree/","text":"cntree.py This module creates a tree of the specified directory, with paths being ignored by the filter list and names being formatted according to the specified formats. It creates both text and HTML versions. The HTML version has the ability to display checkboxes that show the state of each item as either checked, unchecked, or indeterminate, according to their child checkboxes' values. CNTree Generate a file tree in text format with the names formatted according to some format strings Methods: Name Description main Creates a tree from the given start directory, using filter list, This class builds the tree as a complete string, ready to be printed to stdout or a file. Source code in cnlib/cntree.py class CNTree: \"\"\" Generate a file tree in text format with the names formatted according to some format strings Methods: main: Creates a tree from the given start directory, using filter list, directory and file formats This class builds the tree as a complete string, ready to be printed to stdout or a file. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # console/terminal values for the individual prefix/connector chars S_CHAR_VERT = \"\\u2502\" # vertical join (pipe) S_CHAR_HORZ = \"\\u2500\" # horizontal join (full-width dash) S_CHAR_TEE = \"\\u251c\" # tee join (not last item) S_CHAR_ELL = \"\\u2514\" # elbow join (last item) S_CHAR_SPACE = \" \" # single space char # char sequences for the prefix/connector char sets # NB: these must always be equal length S_PREFIX_VERT = f\"{S_CHAR_VERT}{S_CHAR_SPACE}\" # next level (\"| \") S_PREFIX_NONE = f\"{S_CHAR_SPACE}{S_CHAR_SPACE}\" # skip level (\" \") S_CONNECTOR_TEE = f\"{S_CHAR_TEE}{S_CHAR_HORZ}\" # next sub item (\"T-\") S_CONNECTOR_ELL = f\"{S_CHAR_ELL}{S_CHAR_HORZ}\" # last sub item (\"L-\") # the default directory/file name formats # NB: NAME alone is used for the top level directory name # DIR is used for subdirectories and should have a leading space to # separate it from the prefix and/or connector # FILE has the same purpose as DIR, but for files (DUH!) S_FORMAT_NAME = \"$NAME\" S_FORMAT_DIR = f\" {S_FORMAT_NAME}/\" S_FORMAT_FILE = f\" {S_FORMAT_NAME}\" # error messages # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # custom sorting order S_SORT_ORDER = \"_.\" # sort first char of name in this order (above ord) # style the html lists S_DEF_CSS = \"\"\"ul { list-style-type: none; padding-left: 20px; }\"\"\" # -------------------------------------------------------------------------- # html stuff # NB: DO NOT MESS WITH THIS!!! # prolog (html/head/style/body) # NB: format params are self._css, root name, and root id S_HTML_PROLOG = \"\"\"<!DOCTYPE html> <html> <head> <style> {0} </style> </head> <body> <ul> <li> <input type=\"checkbox\" id=\"{2}\"> <label for=\"{2}\">{1}</label> <ul>\"\"\" # epilog (what comes after the checkbox list) S_HTML_EPILOG = \"\"\" </ul> </li> </ul> <script> // NB: https://codepen.io/girish/pen/BaWMGKp // helper func to create a flat array from a NodeList nodeArray = (parent, selector) => Array.from(parent.querySelectorAll(selector)); // get all checkboxes from document allChecks = nodeArray(document, 'input[type=\"checkbox\"]'); // global document listener (add to all inputs) addEventListener('change', e => { // get object that changed check = e.target; // if event did not come from a checkbox in our list if (allChecks.indexOf(check) === -1) return; // check/uncheck children based on parent state parent = check.parentNode; children = nodeArray(parent, 'input[type=\"checkbox\"]'); children.forEach(child => child.checked = check.checked ); // traverse up from target check while (check) { // find parent checkbox parent = check.closest('ul'); parent = parent.parentNode; parent = parent.querySelector('input[type=\"checkbox\"]'); // find sibling checkboxes siblings = parent.closest('li'); siblings = siblings.querySelector('ul'); siblings = nodeArray(siblings, 'input[type=\"checkbox\"]'); // get checked state of siblings // are every or some siblings checked? siblingsMap = siblings.map(check => check.checked); every = siblingsMap.every(Boolean); some = siblingsMap.some(Boolean); // check parent if all child siblings are checked // set indeterminate if some (not all and not none) are checked parent.checked = every; parent.indeterminate = !every && every !== some; // prepare for next loop check = check != parent ? parent : 0; } // save current state save(); }); // save current state function save() { // for each checkbox allChecks.forEach(check => { // get all the stuff id = check.id; ind = check.indeterminate; checked = check.checked; // if it is -, save that if (ind) { localStorage.setItem(id, 'ind'); // not -, save checked or not } else { localStorage.setItem(id, checked); } }); }; // load previous state window.onload = function () { // for each checkbox allChecks.forEach(check => { // get all the stuff id = check.id; ind = localStorage.getItem(id) === 'ind'; checked = localStorage.getItem(id) === 'true'; // if it was -, set to - if (ind) { check.indeterminate = true // if it was not -, set to old state } else { check.checked = checked; } }); }; </script> </body> </html> <!-- -) --> \"\"\" # start of new entry (file, folder) # NB: format params are indent string, self._id, and entry name S_ENTRY_OPEN = \"\"\" {0}<li> {0} <input type='checkbox' id='{1}'> {0} <label for='{1}'>{2}</label> {0} <ul>\"\"\" # end of entry (close child list, close entry) # NB: format param is indent string S_ENTRY_CLOSE = \"\"\" {0} </ul> {0}</li>\"\"\" # indent used in <li> to align better S_HTML_INDENT = \" \" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initializes the new object # -------------------------------------------------------------------------- def __init__( self, start_dir, filter_list=None, fmt_name=\"\", dir_format=\"\", file_format=\"\", dirs_only=False, sort=True, sort_files=False, ignore_case=False, css=None, ): \"\"\" Initializes the new object Args: start_dir: String or Path to the root directory of the tree filter_list: List of directory/file names to filter out (default: None) dir_format: Format to use for directories (default:\"$NAME/\") file_format: Format to use for files (default: \"$NAME\") dirs_only: Only list directories (default: False) sort: Whether to use the sort_files arg (default: True) sort_files: If True, sort files above dirs, or if False, sort dirs above files (Ignored if sort is False) (default: False) ignore_case: If True, sort entries regardless of case, or if False, uppercase alpha characters take precedence (default: False) css: Custom css string to use for HTML output Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties self._start_dir = Path(start_dir) if not self._start_dir.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._start_dir)) if not self._start_dir.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._start_dir)) # fill in param props self._filter_list = filter_list if self._filter_list is None: self._filter_list = [] self._fmt_name = self.S_FORMAT_NAME if fmt_name and self._fmt_name in fmt_name: self._fmt_name = fmt_name self._dir_format = self.S_FORMAT_DIR if dir_format and self._fmt_name in dir_format: self._dir_format = dir_format self._file_format = self.S_FORMAT_FILE if file_format and self._fmt_name in file_format: self._file_format = file_format self._dirs_only = dirs_only self._ignore_case = ignore_case self._sort = sort self._sort_files = sort_files if not css: self._css = self.S_DEF_CSS # create private props self._root_lead = \"\" self._dir_lead = \"\" self._sort_order = {} self._tree = [] self.text = \"\" # html stuff self._level = 2 # initial indent level for html self._id = \"\" # build a unique id for entries (dot separated path) self.html = \"\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Creates a tree from the given start directory, using filter list, # directory and file formats # -------------------------------------------------------------------------- def make_tree(self): \"\"\" Creates a tree from the given start directory, using filter list, directory and file formats Returns: The current tree as a string Raises: OSError: If the start_dir parameter is None or does not contain a path to a valid directory \"\"\" # get filters from globs self._get_filter_list() # get leads (extra spaces before prefix/connector) self._get_leads() # create custom sort dictionary self._get_sort_order() # add root to tree self._add_root() # enumerate the start dir and add its contents, starting recursion self._add_contents(self._start_dir) # turn the final tree array into string and html self.text = \"\\n\".join(self._tree) self.html += self.S_HTML_EPILOG # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Adds the root to the tree # -------------------------------------------------------------------------- def _add_root(self): \"\"\" Adds the root to the tree This function adds the root item to the tree. It just strips the leading blanks to make sure the root is left-aligned. \"\"\" # format the root directory name to a display name and add it fmt_root = self._dir_format.lstrip() rep_name = fmt_root.replace(self._fmt_name, self._start_dir.name) # setup text file self._tree.append(rep_name) # setup html file self._id = self._start_dir.name self.html += self.S_HTML_PROLOG.format(self._css, rep_name, self._id) # -------------------------------------------------------------------------- # Enumerates the given directory and adds its contents to the tree # -------------------------------------------------------------------------- def _add_contents(self, item, prefix=\"\"): \"\"\" Enumerates the given directory and adds its contents to the tree Args: item: Path object we are adding prefix: Current prefix (combination of pipes/blanks) to show the level of indentation This method is called recursively to build up the visual level of indentation, as well as add directory contents to the tree. It does a lot of the heavy lifting to determine what gets printed, and how. \"\"\" # ---------------------------------------------------------------------- # fix up items (sort, filter) # enum all items in the dir (files and folders) and convert to list # NB: we need a list rather than a generator, since we want everything # at once (iterdir is a generator, and so yields) # this grabs the whole shebang at once items = list(item.iterdir()) # sort everything, first by custom sort (which handles name), then # by type (folders first), then removes anything in the filter list # it also removes files if the dirs_only value is true # the key function's result is used to determine an item's position # based on a bubble sort # NB: the hidden param to the \"key\" function is self is an iterator of # items i.e: # self._sort_by_name([item for item in items]) items.sort(key=self._sort_by_name) # sort works by iterating through a list. this function passes every # item through the is_file() test to get its result # the item.is_file() might seem backwards, but sort works by placing a # false(0) above a true(1), so an item that is NOT a file (ie. a dir, # and thus a 0), will be placed above an item that IS a file (and thus # a 1) if self._sort: if not self._sort_files: items.sort(key=lambda item: item.is_file()) else: items.sort(key=lambda item: item.is_dir()) # remove the filtered paths items = [item for item in items if item not in self._filter_list] # list only dirs if flag is set if self._dirs_only: items = [item for item in items if item.is_dir()] # ---------------------------------------------------------------------- # get number of files/directories (for determining connector) count = len(items) # for each entry for index, an_item in enumerate(items): # ------------------------------------------------------------------ # text stuff # get the type of connector based on position in enum connector = ( self.S_CONNECTOR_TEE if index < (count - 1) else self.S_CONNECTOR_ELL ) # get format string based on whether it is a dir or file fmt = self._dir_format if an_item.is_dir() else self._file_format # replace name in format string rep_name = fmt.replace(self.S_FORMAT_NAME, an_item.name) # add the item to the tree self._tree.append( f\"{self._root_lead}{prefix}{connector}{rep_name}\" ) # ------------------------------------------------------------------ # html stuff # increase id level self._id += \".\" + an_item.name # increase indent self._level += 2 indent = self.S_HTML_INDENT * self._level # add the item to the tree self.html += self.S_ENTRY_OPEN.format(indent, self._id, rep_name) # ------------------------------------------------------------------ # recurse # if item is a dir if an_item.is_dir(): # -------------------------------------------------------------- # need a fresh prefix for recursion new_prefix = ( self.S_PREFIX_VERT if index < (count - 1) else self.S_PREFIX_NONE ) new_prefix += self._dir_lead # get whole prefix for next recurse new_prefix = prefix + new_prefix # recurse with dir and new prefix self._add_contents(an_item, new_prefix) # ------------------------------------------------------------------ # html stuff # back up id from previous level (+1 for dot) self._id = self._id[: -(len(an_item.name) + 1)] # unindent for html indent = self.S_HTML_INDENT * self._level self._level -= 2 # close the item self.html += self.S_ENTRY_CLOSE.format(indent) # -------------------------------------------------------------------------- # Gets the filter_list from paths or globs # -------------------------------------------------------------------------- def _get_filter_list(self): \"\"\" Gets the filter_list from paths or globs Converts entries in filter_list to absolute Path objects relative to start_dir. Globs are acceptable. \"\"\" # sanity check if self._filter_list is None: return # do glob list_filter = [] for item in self._filter_list: res = list(self._start_dir.glob(item)) list_filter.extend(res) # set result self._filter_list = list_filter # -------------------------------------------------------------------------- # Gets the leads (extra spaces) before each entry in the tree # -------------------------------------------------------------------------- def _get_leads(self): \"\"\" Gets the leads (extra spaces) before each entry in the tree Calculates how many spaces should be presented before each entry in the tree. The root folder should have no spaces (left-aligned) and each subsequent entry should add the number of spaces in a directory's format name. This allows us to align the connector with the first character of the FORMAT_NAME variable, skipping things like checkbox brackets. \"\"\" # get the leads (extra indents to line up the pipes/tees/ells) # NB: we don't care about file leads, nothing goes under a file # get the root's format with no leading spaces root_fmt = self._dir_format.lstrip() # set root lead as string root_lead_count = root_fmt.find(self.S_FORMAT_NAME) self._root_lead = \" \" * root_lead_count # set directory lead as string dir_lead_count = self._dir_format.find(self.S_FORMAT_NAME) self._dir_lead = \" \" * dir_lead_count # -------------------------------------------------------------------------- # Gets the sort order for custom sorting by name # -------------------------------------------------------------------------- def _get_sort_order(self): \"\"\" Gets the sort order for custom sorting by name This just fixes a personal quirk of mine. The default sorting order in Python sorts names starting with a dot (.) above a name starting with an underscore (_) (as per string.printable), which for me is dependant on my locale, en_US, YMMV. This does not match my IDE, VSCode, and I want the tree to match my File Explorer in my IDE. So to fix this, I created a custom sorter that reverses that. It's not really necessary, but it does the job. This function creates a dict in the form of: {char:index[, ...]} where: char is the character in the SORT_ORDER string index is the ordinal of that char (starting at the lowest negative ordinal) so that: SORT_ORDER = \"_.\" results in: self._sort_order = {\"_\": -2, \".\": -1} most of this came from: https://stackoverflow.com/questions/75301122/how-can-i-change-how-python-sort-deals-with-punctuation \"\"\" # get length of string to count backwards sort_len = len(self.S_SORT_ORDER) # for each char in string for index, char in enumerate(self.S_SORT_ORDER): # make a dict entry for the char and its new ord self._sort_order[char] = index - sort_len # -------------------------------------------------------------------------- # Sorts items in the item list according to the item name # -------------------------------------------------------------------------- def _sort_by_name(self, item): \"\"\" Sorts items in the item list according to the item name Args: item: Path object to sort Returns: The index of the sorted item Sorts items in the item list according to the item name, using a simple bubble sort (i.e. step through each char in a string, promoting it based on it's value) \"\"\" # check if we need to lowercase based on the build_tree param tmp_item = item.name if self._ignore_case: tmp_item = item.name.lower() # get the ordinal position of each char # NB: if the key (char) is present, the get() function returns the # value of the specified key. if the key is not present, it returns the # second (ord of char in string.printable, i.e. a=0, b=1, c=2, etc.) # this is why we need to know about the ignore_case, since if it is # False, uppercase will always take precedence over lowercase (at least # in en_US str.printable, again YMMV) return [self._sort_order.get(char, ord(char)) for char in tmp_item] __init__(start_dir, filter_list=None, fmt_name='', dir_format='', file_format='', dirs_only=False, sort=True, sort_files=False, ignore_case=False, css=None) Initializes the new object Parameters: Name Type Description Default start_dir String or Path to the root directory of the tree required filter_list List of directory/file names to filter out (default: None dir_format Format to use for directories (default:\"$NAME/\") '' file_format Format to use for files (default: \"$NAME\") '' dirs_only Only list directories (default: False) False sort Whether to use the sort_files arg (default: True) True sort_files If True, sort files above dirs, or if False, sort dirs False above files (Ignored if sort is False) (default False) required ignore_case If True, sort entries regardless of case, or if False, False uppercase alpha characters take precedence (default False) required css Custom css string to use for HTML output None Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in cnlib/cntree.py def __init__( self, start_dir, filter_list=None, fmt_name=\"\", dir_format=\"\", file_format=\"\", dirs_only=False, sort=True, sort_files=False, ignore_case=False, css=None, ): \"\"\" Initializes the new object Args: start_dir: String or Path to the root directory of the tree filter_list: List of directory/file names to filter out (default: None) dir_format: Format to use for directories (default:\"$NAME/\") file_format: Format to use for files (default: \"$NAME\") dirs_only: Only list directories (default: False) sort: Whether to use the sort_files arg (default: True) sort_files: If True, sort files above dirs, or if False, sort dirs above files (Ignored if sort is False) (default: False) ignore_case: If True, sort entries regardless of case, or if False, uppercase alpha characters take precedence (default: False) css: Custom css string to use for HTML output Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties self._start_dir = Path(start_dir) if not self._start_dir.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._start_dir)) if not self._start_dir.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._start_dir)) # fill in param props self._filter_list = filter_list if self._filter_list is None: self._filter_list = [] self._fmt_name = self.S_FORMAT_NAME if fmt_name and self._fmt_name in fmt_name: self._fmt_name = fmt_name self._dir_format = self.S_FORMAT_DIR if dir_format and self._fmt_name in dir_format: self._dir_format = dir_format self._file_format = self.S_FORMAT_FILE if file_format and self._fmt_name in file_format: self._file_format = file_format self._dirs_only = dirs_only self._ignore_case = ignore_case self._sort = sort self._sort_files = sort_files if not css: self._css = self.S_DEF_CSS # create private props self._root_lead = \"\" self._dir_lead = \"\" self._sort_order = {} self._tree = [] self.text = \"\" # html stuff self._level = 2 # initial indent level for html self._id = \"\" # build a unique id for entries (dot separated path) self.html = \"\" make_tree() Creates a tree from the given start directory, using filter list, directory and file formats Returns: Type Description The current tree as a string Raises: Type Description OSError If the start_dir parameter is None or does not contain a path to a valid directory Source code in cnlib/cntree.py def make_tree(self): \"\"\" Creates a tree from the given start directory, using filter list, directory and file formats Returns: The current tree as a string Raises: OSError: If the start_dir parameter is None or does not contain a path to a valid directory \"\"\" # get filters from globs self._get_filter_list() # get leads (extra spaces before prefix/connector) self._get_leads() # create custom sort dictionary self._get_sort_order() # add root to tree self._add_root() # enumerate the start dir and add its contents, starting recursion self._add_contents(self._start_dir) # turn the final tree array into string and html self.text = \"\\n\".join(self._tree) self.html += self.S_HTML_EPILOG","title":"cntree.py"},{"location":"API/cnlib/cntree/#cntreepy","text":"This module creates a tree of the specified directory, with paths being ignored by the filter list and names being formatted according to the specified formats. It creates both text and HTML versions. The HTML version has the ability to display checkboxes that show the state of each item as either checked, unchecked, or indeterminate, according to their child checkboxes' values.","title":"cntree.py"},{"location":"API/cnlib/cntree/#cnlib.cntree.CNTree","text":"Generate a file tree in text format with the names formatted according to some format strings Methods: Name Description main Creates a tree from the given start directory, using filter list, This class builds the tree as a complete string, ready to be printed to stdout or a file. Source code in cnlib/cntree.py class CNTree: \"\"\" Generate a file tree in text format with the names formatted according to some format strings Methods: main: Creates a tree from the given start directory, using filter list, directory and file formats This class builds the tree as a complete string, ready to be printed to stdout or a file. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # console/terminal values for the individual prefix/connector chars S_CHAR_VERT = \"\\u2502\" # vertical join (pipe) S_CHAR_HORZ = \"\\u2500\" # horizontal join (full-width dash) S_CHAR_TEE = \"\\u251c\" # tee join (not last item) S_CHAR_ELL = \"\\u2514\" # elbow join (last item) S_CHAR_SPACE = \" \" # single space char # char sequences for the prefix/connector char sets # NB: these must always be equal length S_PREFIX_VERT = f\"{S_CHAR_VERT}{S_CHAR_SPACE}\" # next level (\"| \") S_PREFIX_NONE = f\"{S_CHAR_SPACE}{S_CHAR_SPACE}\" # skip level (\" \") S_CONNECTOR_TEE = f\"{S_CHAR_TEE}{S_CHAR_HORZ}\" # next sub item (\"T-\") S_CONNECTOR_ELL = f\"{S_CHAR_ELL}{S_CHAR_HORZ}\" # last sub item (\"L-\") # the default directory/file name formats # NB: NAME alone is used for the top level directory name # DIR is used for subdirectories and should have a leading space to # separate it from the prefix and/or connector # FILE has the same purpose as DIR, but for files (DUH!) S_FORMAT_NAME = \"$NAME\" S_FORMAT_DIR = f\" {S_FORMAT_NAME}/\" S_FORMAT_FILE = f\" {S_FORMAT_NAME}\" # error messages # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # custom sorting order S_SORT_ORDER = \"_.\" # sort first char of name in this order (above ord) # style the html lists S_DEF_CSS = \"\"\"ul { list-style-type: none; padding-left: 20px; }\"\"\" # -------------------------------------------------------------------------- # html stuff # NB: DO NOT MESS WITH THIS!!! # prolog (html/head/style/body) # NB: format params are self._css, root name, and root id S_HTML_PROLOG = \"\"\"<!DOCTYPE html> <html> <head> <style> {0} </style> </head> <body> <ul> <li> <input type=\"checkbox\" id=\"{2}\"> <label for=\"{2}\">{1}</label> <ul>\"\"\" # epilog (what comes after the checkbox list) S_HTML_EPILOG = \"\"\" </ul> </li> </ul> <script> // NB: https://codepen.io/girish/pen/BaWMGKp // helper func to create a flat array from a NodeList nodeArray = (parent, selector) => Array.from(parent.querySelectorAll(selector)); // get all checkboxes from document allChecks = nodeArray(document, 'input[type=\"checkbox\"]'); // global document listener (add to all inputs) addEventListener('change', e => { // get object that changed check = e.target; // if event did not come from a checkbox in our list if (allChecks.indexOf(check) === -1) return; // check/uncheck children based on parent state parent = check.parentNode; children = nodeArray(parent, 'input[type=\"checkbox\"]'); children.forEach(child => child.checked = check.checked ); // traverse up from target check while (check) { // find parent checkbox parent = check.closest('ul'); parent = parent.parentNode; parent = parent.querySelector('input[type=\"checkbox\"]'); // find sibling checkboxes siblings = parent.closest('li'); siblings = siblings.querySelector('ul'); siblings = nodeArray(siblings, 'input[type=\"checkbox\"]'); // get checked state of siblings // are every or some siblings checked? siblingsMap = siblings.map(check => check.checked); every = siblingsMap.every(Boolean); some = siblingsMap.some(Boolean); // check parent if all child siblings are checked // set indeterminate if some (not all and not none) are checked parent.checked = every; parent.indeterminate = !every && every !== some; // prepare for next loop check = check != parent ? parent : 0; } // save current state save(); }); // save current state function save() { // for each checkbox allChecks.forEach(check => { // get all the stuff id = check.id; ind = check.indeterminate; checked = check.checked; // if it is -, save that if (ind) { localStorage.setItem(id, 'ind'); // not -, save checked or not } else { localStorage.setItem(id, checked); } }); }; // load previous state window.onload = function () { // for each checkbox allChecks.forEach(check => { // get all the stuff id = check.id; ind = localStorage.getItem(id) === 'ind'; checked = localStorage.getItem(id) === 'true'; // if it was -, set to - if (ind) { check.indeterminate = true // if it was not -, set to old state } else { check.checked = checked; } }); }; </script> </body> </html> <!-- -) --> \"\"\" # start of new entry (file, folder) # NB: format params are indent string, self._id, and entry name S_ENTRY_OPEN = \"\"\" {0}<li> {0} <input type='checkbox' id='{1}'> {0} <label for='{1}'>{2}</label> {0} <ul>\"\"\" # end of entry (close child list, close entry) # NB: format param is indent string S_ENTRY_CLOSE = \"\"\" {0} </ul> {0}</li>\"\"\" # indent used in <li> to align better S_HTML_INDENT = \" \" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initializes the new object # -------------------------------------------------------------------------- def __init__( self, start_dir, filter_list=None, fmt_name=\"\", dir_format=\"\", file_format=\"\", dirs_only=False, sort=True, sort_files=False, ignore_case=False, css=None, ): \"\"\" Initializes the new object Args: start_dir: String or Path to the root directory of the tree filter_list: List of directory/file names to filter out (default: None) dir_format: Format to use for directories (default:\"$NAME/\") file_format: Format to use for files (default: \"$NAME\") dirs_only: Only list directories (default: False) sort: Whether to use the sort_files arg (default: True) sort_files: If True, sort files above dirs, or if False, sort dirs above files (Ignored if sort is False) (default: False) ignore_case: If True, sort entries regardless of case, or if False, uppercase alpha characters take precedence (default: False) css: Custom css string to use for HTML output Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties self._start_dir = Path(start_dir) if not self._start_dir.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._start_dir)) if not self._start_dir.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._start_dir)) # fill in param props self._filter_list = filter_list if self._filter_list is None: self._filter_list = [] self._fmt_name = self.S_FORMAT_NAME if fmt_name and self._fmt_name in fmt_name: self._fmt_name = fmt_name self._dir_format = self.S_FORMAT_DIR if dir_format and self._fmt_name in dir_format: self._dir_format = dir_format self._file_format = self.S_FORMAT_FILE if file_format and self._fmt_name in file_format: self._file_format = file_format self._dirs_only = dirs_only self._ignore_case = ignore_case self._sort = sort self._sort_files = sort_files if not css: self._css = self.S_DEF_CSS # create private props self._root_lead = \"\" self._dir_lead = \"\" self._sort_order = {} self._tree = [] self.text = \"\" # html stuff self._level = 2 # initial indent level for html self._id = \"\" # build a unique id for entries (dot separated path) self.html = \"\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Creates a tree from the given start directory, using filter list, # directory and file formats # -------------------------------------------------------------------------- def make_tree(self): \"\"\" Creates a tree from the given start directory, using filter list, directory and file formats Returns: The current tree as a string Raises: OSError: If the start_dir parameter is None or does not contain a path to a valid directory \"\"\" # get filters from globs self._get_filter_list() # get leads (extra spaces before prefix/connector) self._get_leads() # create custom sort dictionary self._get_sort_order() # add root to tree self._add_root() # enumerate the start dir and add its contents, starting recursion self._add_contents(self._start_dir) # turn the final tree array into string and html self.text = \"\\n\".join(self._tree) self.html += self.S_HTML_EPILOG # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Adds the root to the tree # -------------------------------------------------------------------------- def _add_root(self): \"\"\" Adds the root to the tree This function adds the root item to the tree. It just strips the leading blanks to make sure the root is left-aligned. \"\"\" # format the root directory name to a display name and add it fmt_root = self._dir_format.lstrip() rep_name = fmt_root.replace(self._fmt_name, self._start_dir.name) # setup text file self._tree.append(rep_name) # setup html file self._id = self._start_dir.name self.html += self.S_HTML_PROLOG.format(self._css, rep_name, self._id) # -------------------------------------------------------------------------- # Enumerates the given directory and adds its contents to the tree # -------------------------------------------------------------------------- def _add_contents(self, item, prefix=\"\"): \"\"\" Enumerates the given directory and adds its contents to the tree Args: item: Path object we are adding prefix: Current prefix (combination of pipes/blanks) to show the level of indentation This method is called recursively to build up the visual level of indentation, as well as add directory contents to the tree. It does a lot of the heavy lifting to determine what gets printed, and how. \"\"\" # ---------------------------------------------------------------------- # fix up items (sort, filter) # enum all items in the dir (files and folders) and convert to list # NB: we need a list rather than a generator, since we want everything # at once (iterdir is a generator, and so yields) # this grabs the whole shebang at once items = list(item.iterdir()) # sort everything, first by custom sort (which handles name), then # by type (folders first), then removes anything in the filter list # it also removes files if the dirs_only value is true # the key function's result is used to determine an item's position # based on a bubble sort # NB: the hidden param to the \"key\" function is self is an iterator of # items i.e: # self._sort_by_name([item for item in items]) items.sort(key=self._sort_by_name) # sort works by iterating through a list. this function passes every # item through the is_file() test to get its result # the item.is_file() might seem backwards, but sort works by placing a # false(0) above a true(1), so an item that is NOT a file (ie. a dir, # and thus a 0), will be placed above an item that IS a file (and thus # a 1) if self._sort: if not self._sort_files: items.sort(key=lambda item: item.is_file()) else: items.sort(key=lambda item: item.is_dir()) # remove the filtered paths items = [item for item in items if item not in self._filter_list] # list only dirs if flag is set if self._dirs_only: items = [item for item in items if item.is_dir()] # ---------------------------------------------------------------------- # get number of files/directories (for determining connector) count = len(items) # for each entry for index, an_item in enumerate(items): # ------------------------------------------------------------------ # text stuff # get the type of connector based on position in enum connector = ( self.S_CONNECTOR_TEE if index < (count - 1) else self.S_CONNECTOR_ELL ) # get format string based on whether it is a dir or file fmt = self._dir_format if an_item.is_dir() else self._file_format # replace name in format string rep_name = fmt.replace(self.S_FORMAT_NAME, an_item.name) # add the item to the tree self._tree.append( f\"{self._root_lead}{prefix}{connector}{rep_name}\" ) # ------------------------------------------------------------------ # html stuff # increase id level self._id += \".\" + an_item.name # increase indent self._level += 2 indent = self.S_HTML_INDENT * self._level # add the item to the tree self.html += self.S_ENTRY_OPEN.format(indent, self._id, rep_name) # ------------------------------------------------------------------ # recurse # if item is a dir if an_item.is_dir(): # -------------------------------------------------------------- # need a fresh prefix for recursion new_prefix = ( self.S_PREFIX_VERT if index < (count - 1) else self.S_PREFIX_NONE ) new_prefix += self._dir_lead # get whole prefix for next recurse new_prefix = prefix + new_prefix # recurse with dir and new prefix self._add_contents(an_item, new_prefix) # ------------------------------------------------------------------ # html stuff # back up id from previous level (+1 for dot) self._id = self._id[: -(len(an_item.name) + 1)] # unindent for html indent = self.S_HTML_INDENT * self._level self._level -= 2 # close the item self.html += self.S_ENTRY_CLOSE.format(indent) # -------------------------------------------------------------------------- # Gets the filter_list from paths or globs # -------------------------------------------------------------------------- def _get_filter_list(self): \"\"\" Gets the filter_list from paths or globs Converts entries in filter_list to absolute Path objects relative to start_dir. Globs are acceptable. \"\"\" # sanity check if self._filter_list is None: return # do glob list_filter = [] for item in self._filter_list: res = list(self._start_dir.glob(item)) list_filter.extend(res) # set result self._filter_list = list_filter # -------------------------------------------------------------------------- # Gets the leads (extra spaces) before each entry in the tree # -------------------------------------------------------------------------- def _get_leads(self): \"\"\" Gets the leads (extra spaces) before each entry in the tree Calculates how many spaces should be presented before each entry in the tree. The root folder should have no spaces (left-aligned) and each subsequent entry should add the number of spaces in a directory's format name. This allows us to align the connector with the first character of the FORMAT_NAME variable, skipping things like checkbox brackets. \"\"\" # get the leads (extra indents to line up the pipes/tees/ells) # NB: we don't care about file leads, nothing goes under a file # get the root's format with no leading spaces root_fmt = self._dir_format.lstrip() # set root lead as string root_lead_count = root_fmt.find(self.S_FORMAT_NAME) self._root_lead = \" \" * root_lead_count # set directory lead as string dir_lead_count = self._dir_format.find(self.S_FORMAT_NAME) self._dir_lead = \" \" * dir_lead_count # -------------------------------------------------------------------------- # Gets the sort order for custom sorting by name # -------------------------------------------------------------------------- def _get_sort_order(self): \"\"\" Gets the sort order for custom sorting by name This just fixes a personal quirk of mine. The default sorting order in Python sorts names starting with a dot (.) above a name starting with an underscore (_) (as per string.printable), which for me is dependant on my locale, en_US, YMMV. This does not match my IDE, VSCode, and I want the tree to match my File Explorer in my IDE. So to fix this, I created a custom sorter that reverses that. It's not really necessary, but it does the job. This function creates a dict in the form of: {char:index[, ...]} where: char is the character in the SORT_ORDER string index is the ordinal of that char (starting at the lowest negative ordinal) so that: SORT_ORDER = \"_.\" results in: self._sort_order = {\"_\": -2, \".\": -1} most of this came from: https://stackoverflow.com/questions/75301122/how-can-i-change-how-python-sort-deals-with-punctuation \"\"\" # get length of string to count backwards sort_len = len(self.S_SORT_ORDER) # for each char in string for index, char in enumerate(self.S_SORT_ORDER): # make a dict entry for the char and its new ord self._sort_order[char] = index - sort_len # -------------------------------------------------------------------------- # Sorts items in the item list according to the item name # -------------------------------------------------------------------------- def _sort_by_name(self, item): \"\"\" Sorts items in the item list according to the item name Args: item: Path object to sort Returns: The index of the sorted item Sorts items in the item list according to the item name, using a simple bubble sort (i.e. step through each char in a string, promoting it based on it's value) \"\"\" # check if we need to lowercase based on the build_tree param tmp_item = item.name if self._ignore_case: tmp_item = item.name.lower() # get the ordinal position of each char # NB: if the key (char) is present, the get() function returns the # value of the specified key. if the key is not present, it returns the # second (ord of char in string.printable, i.e. a=0, b=1, c=2, etc.) # this is why we need to know about the ignore_case, since if it is # False, uppercase will always take precedence over lowercase (at least # in en_US str.printable, again YMMV) return [self._sort_order.get(char, ord(char)) for char in tmp_item]","title":"CNTree"},{"location":"API/cnlib/cntree/#cnlib.cntree.CNTree.__init__","text":"Initializes the new object Parameters: Name Type Description Default start_dir String or Path to the root directory of the tree required filter_list List of directory/file names to filter out (default: None dir_format Format to use for directories (default:\"$NAME/\") '' file_format Format to use for files (default: \"$NAME\") '' dirs_only Only list directories (default: False) False sort Whether to use the sort_files arg (default: True) True sort_files If True, sort files above dirs, or if False, sort dirs False above files (Ignored if sort is False) (default False) required ignore_case If True, sort entries regardless of case, or if False, False uppercase alpha characters take precedence (default False) required css Custom css string to use for HTML output None Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in cnlib/cntree.py def __init__( self, start_dir, filter_list=None, fmt_name=\"\", dir_format=\"\", file_format=\"\", dirs_only=False, sort=True, sort_files=False, ignore_case=False, css=None, ): \"\"\" Initializes the new object Args: start_dir: String or Path to the root directory of the tree filter_list: List of directory/file names to filter out (default: None) dir_format: Format to use for directories (default:\"$NAME/\") file_format: Format to use for files (default: \"$NAME\") dirs_only: Only list directories (default: False) sort: Whether to use the sort_files arg (default: True) sort_files: If True, sort files above dirs, or if False, sort dirs above files (Ignored if sort is False) (default: False) ignore_case: If True, sort entries regardless of case, or if False, uppercase alpha characters take precedence (default: False) css: Custom css string to use for HTML output Creates a tree from the given start directory. The start_dir can be an absolute path, a relative path, or a Path object, but MUST point to a directory. If start_dir does not point to a directory, an OSError will be raised. If start_dir == None, an OSError will be raised. If start_dir == \"\", the current directory is used. Items in the filter list will be skipped. These items can be relative paths, or globs. The format strings for directory and file names will have the value of \"fmt_name\" replaced by the directory or file name. Example: (assuming \"fmt_name\" is set to \"$NAME\") dir_format = \" [] $NAME/\" item.name = \"Foo\" result = \" [] Foo/\" Also, leading spaces in dir_format, when applied to the start_dir name, will be left-trimmed to make the tree start at the first column. Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set the initial values of properties self._start_dir = Path(start_dir) if not self._start_dir.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._start_dir)) if not self._start_dir.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._start_dir)) # fill in param props self._filter_list = filter_list if self._filter_list is None: self._filter_list = [] self._fmt_name = self.S_FORMAT_NAME if fmt_name and self._fmt_name in fmt_name: self._fmt_name = fmt_name self._dir_format = self.S_FORMAT_DIR if dir_format and self._fmt_name in dir_format: self._dir_format = dir_format self._file_format = self.S_FORMAT_FILE if file_format and self._fmt_name in file_format: self._file_format = file_format self._dirs_only = dirs_only self._ignore_case = ignore_case self._sort = sort self._sort_files = sort_files if not css: self._css = self.S_DEF_CSS # create private props self._root_lead = \"\" self._dir_lead = \"\" self._sort_order = {} self._tree = [] self.text = \"\" # html stuff self._level = 2 # initial indent level for html self._id = \"\" # build a unique id for entries (dot separated path) self.html = \"\"","title":"__init__"},{"location":"API/cnlib/cntree/#cnlib.cntree.CNTree.make_tree","text":"Creates a tree from the given start directory, using filter list, directory and file formats Returns: Type Description The current tree as a string Raises: Type Description OSError If the start_dir parameter is None or does not contain a path to a valid directory Source code in cnlib/cntree.py def make_tree(self): \"\"\" Creates a tree from the given start directory, using filter list, directory and file formats Returns: The current tree as a string Raises: OSError: If the start_dir parameter is None or does not contain a path to a valid directory \"\"\" # get filters from globs self._get_filter_list() # get leads (extra spaces before prefix/connector) self._get_leads() # create custom sort dictionary self._get_sort_order() # add root to tree self._add_root() # enumerate the start dir and add its contents, starting recursion self._add_contents(self._start_dir) # turn the final tree array into string and html self.text = \"\\n\".join(self._tree) self.html += self.S_HTML_EPILOG","title":"make_tree"},{"location":"API/cnlib/cnvenv/","text":"cnvenv.py A class to make handling of venv folders easier CNVenv A class to make handling of venv folders easier Methods: Name Description create Creates a new venv given the init params install_reqs Install packages to venv from the reqs_file property freeze Freeze packages in the venv folder to the file_reqs property This class provides methods to create, freeze, and install dependencies in the project's venv folder. Source code in cnlib/cnvenv.py class CNVenv: \"\"\" A class to make handling of venv folders easier Methods: create: Creates a new venv given the __init__ params install_reqs: Install packages to venv from the reqs_file property freeze: Freeze packages in the venv folder to the file_reqs property This class provides methods to create, freeze, and install dependencies in the project's venv folder. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # NB format param is self._dir_venv S_CMD_CREATE = \"python -Xfrozen_modules=off -m venv {}\" # NB: format params are venv.parent, venv.name, path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # NB: format params are venv.parent, venv.name, path to reqs file S_CMD_FREEZE = ( \"cd {}; \" \". {}/bin/activate; \" \"python \" \"-Xfrozen_modules=off \" \"-m pip freeze \" \"-l --exclude-editable \" \"--require-virtualenv \" \"> \" \"{}\" ) # error messages # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self, dir_prj, dir_venv): \"\"\" Initialize the new object Args: dir_prj: The path to the project's root dir (can be a string or a Path object) dir_venv: The path or name of the resulting venv folder (can be a string or a Path object, absolute or relative to dir_prj) Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # save prj dir self._dir_prj = Path(dir_prj) if not self._dir_prj.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._dir_prj)) if not self._dir_prj.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._dir_prj)) # if param is not abs, make abs rel to prj dir self._dir_venv = Path(dir_venv) if not self._dir_venv.is_absolute(): self._dir_venv = self._dir_prj / dir_venv # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Creates a new venv given the __init__ params # -------------------------------------------------------------------------- def create(self): \"\"\" Creates a new venv given the __init__ params Raises: cnlib.cnfunctions.CNRunError if the create fails Creates a new venv folder with the parameters provided at create time. \"\"\" # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Install packages to venv from the reqs_file property # -------------------------------------------------------------------------- def install_reqs(self, file_reqs): \"\"\" Install packages to venv from the reqs_file property Args: file_reqs: File to load requirements Raises: cnlib.cnfunctions.CNRunError if the reqs install fails This method takes requirements in the reqs_file property and installs them in the dir_venv property. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # ignore missing/empty files if not file_reqs.exists() or file_reqs.stat().st_size == 0: return # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True, capture_output=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Freeze packages in the venv folder to the file_reqs property # -------------------------------------------------------------------------- def freeze(self, file_reqs): \"\"\" Freeze packages in the venv folder to the file_reqs property Args: file_reqs: File to save requirements Raises: cnlib.cnfunctions.CNRunError if the freeze fails Freezes current packages in the venv dir into a file for easy installation. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # the command to freeze a venv cmd = self.S_CMD_FREEZE.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e __init__(dir_prj, dir_venv) Initialize the new object Parameters: Name Type Description Default dir_prj The path to the project's root dir (can be a string or a required dir_venv The path or name of the resulting venv folder (can be a required Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. Source code in cnlib/cnvenv.py def __init__(self, dir_prj, dir_venv): \"\"\" Initialize the new object Args: dir_prj: The path to the project's root dir (can be a string or a Path object) dir_venv: The path or name of the resulting venv folder (can be a string or a Path object, absolute or relative to dir_prj) Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # save prj dir self._dir_prj = Path(dir_prj) if not self._dir_prj.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._dir_prj)) if not self._dir_prj.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._dir_prj)) # if param is not abs, make abs rel to prj dir self._dir_venv = Path(dir_venv) if not self._dir_venv.is_absolute(): self._dir_venv = self._dir_prj / dir_venv create() Creates a new venv given the init params Creates a new venv folder with the parameters provided at create time. Source code in cnlib/cnvenv.py def create(self): \"\"\" Creates a new venv given the __init__ params Raises: cnlib.cnfunctions.CNRunError if the create fails Creates a new venv folder with the parameters provided at create time. \"\"\" # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e freeze(file_reqs) Freeze packages in the venv folder to the file_reqs property Parameters: Name Type Description Default file_reqs File to save requirements required Freezes current packages in the venv dir into a file for easy installation. Source code in cnlib/cnvenv.py def freeze(self, file_reqs): \"\"\" Freeze packages in the venv folder to the file_reqs property Args: file_reqs: File to save requirements Raises: cnlib.cnfunctions.CNRunError if the freeze fails Freezes current packages in the venv dir into a file for easy installation. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # the command to freeze a venv cmd = self.S_CMD_FREEZE.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e install_reqs(file_reqs) Install packages to venv from the reqs_file property Parameters: Name Type Description Default file_reqs File to load requirements required This method takes requirements in the reqs_file property and installs them in the dir_venv property. Source code in cnlib/cnvenv.py def install_reqs(self, file_reqs): \"\"\" Install packages to venv from the reqs_file property Args: file_reqs: File to load requirements Raises: cnlib.cnfunctions.CNRunError if the reqs install fails This method takes requirements in the reqs_file property and installs them in the dir_venv property. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # ignore missing/empty files if not file_reqs.exists() or file_reqs.stat().st_size == 0: return # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True, capture_output=True) except F.CNRunError as e: raise e","title":"cnvenv.py"},{"location":"API/cnlib/cnvenv/#cnvenvpy","text":"A class to make handling of venv folders easier","title":"cnvenv.py"},{"location":"API/cnlib/cnvenv/#cnlib.cnvenv.CNVenv","text":"A class to make handling of venv folders easier Methods: Name Description create Creates a new venv given the init params install_reqs Install packages to venv from the reqs_file property freeze Freeze packages in the venv folder to the file_reqs property This class provides methods to create, freeze, and install dependencies in the project's venv folder. Source code in cnlib/cnvenv.py class CNVenv: \"\"\" A class to make handling of venv folders easier Methods: create: Creates a new venv given the __init__ params install_reqs: Install packages to venv from the reqs_file property freeze: Freeze packages in the venv folder to the file_reqs property This class provides methods to create, freeze, and install dependencies in the project's venv folder. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # NB format param is self._dir_venv S_CMD_CREATE = \"python -Xfrozen_modules=off -m venv {}\" # NB: format params are venv.parent, venv.name, path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # NB: format params are venv.parent, venv.name, path to reqs file S_CMD_FREEZE = ( \"cd {}; \" \". {}/bin/activate; \" \"python \" \"-Xfrozen_modules=off \" \"-m pip freeze \" \"-l --exclude-editable \" \"--require-virtualenv \" \"> \" \"{}\" ) # error messages # NB: format param is dir_prj S_ERR_NOT_ABS = \"path {} is not absolute\" # NB: format param is dir_prj S_ERR_NOT_DIR = \"path {} is not a directory\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self, dir_prj, dir_venv): \"\"\" Initialize the new object Args: dir_prj: The path to the project's root dir (can be a string or a Path object) dir_venv: The path or name of the resulting venv folder (can be a string or a Path object, absolute or relative to dir_prj) Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # save prj dir self._dir_prj = Path(dir_prj) if not self._dir_prj.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._dir_prj)) if not self._dir_prj.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._dir_prj)) # if param is not abs, make abs rel to prj dir self._dir_venv = Path(dir_venv) if not self._dir_venv.is_absolute(): self._dir_venv = self._dir_prj / dir_venv # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Creates a new venv given the __init__ params # -------------------------------------------------------------------------- def create(self): \"\"\" Creates a new venv given the __init__ params Raises: cnlib.cnfunctions.CNRunError if the create fails Creates a new venv folder with the parameters provided at create time. \"\"\" # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Install packages to venv from the reqs_file property # -------------------------------------------------------------------------- def install_reqs(self, file_reqs): \"\"\" Install packages to venv from the reqs_file property Args: file_reqs: File to load requirements Raises: cnlib.cnfunctions.CNRunError if the reqs install fails This method takes requirements in the reqs_file property and installs them in the dir_venv property. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # ignore missing/empty files if not file_reqs.exists() or file_reqs.stat().st_size == 0: return # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True, capture_output=True) except F.CNRunError as e: raise e # -------------------------------------------------------------------------- # Freeze packages in the venv folder to the file_reqs property # -------------------------------------------------------------------------- def freeze(self, file_reqs): \"\"\" Freeze packages in the venv folder to the file_reqs property Args: file_reqs: File to save requirements Raises: cnlib.cnfunctions.CNRunError if the freeze fails Freezes current packages in the venv dir into a file for easy installation. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # the command to freeze a venv cmd = self.S_CMD_FREEZE.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e","title":"CNVenv"},{"location":"API/cnlib/cnvenv/#cnlib.cnvenv.CNVenv.__init__","text":"Initialize the new object Parameters: Name Type Description Default dir_prj The path to the project's root dir (can be a string or a required dir_venv The path or name of the resulting venv folder (can be a required Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. Source code in cnlib/cnvenv.py def __init__(self, dir_prj, dir_venv): \"\"\" Initialize the new object Args: dir_prj: The path to the project's root dir (can be a string or a Path object) dir_venv: The path or name of the resulting venv folder (can be a string or a Path object, absolute or relative to dir_prj) Initializes a new instance of the class, setting the default values of its properties, and any other code needed to create a new object. \"\"\" # save prj dir self._dir_prj = Path(dir_prj) if not self._dir_prj.is_absolute(): raise OSError(self.S_ERR_NOT_ABS.format(self._dir_prj)) if not self._dir_prj.is_dir(): raise OSError(self.S_ERR_NOT_DIR.format(self._dir_prj)) # if param is not abs, make abs rel to prj dir self._dir_venv = Path(dir_venv) if not self._dir_venv.is_absolute(): self._dir_venv = self._dir_prj / dir_venv","title":"__init__"},{"location":"API/cnlib/cnvenv/#cnlib.cnvenv.CNVenv.create","text":"Creates a new venv given the init params Creates a new venv folder with the parameters provided at create time. Source code in cnlib/cnvenv.py def create(self): \"\"\" Creates a new venv given the __init__ params Raises: cnlib.cnfunctions.CNRunError if the create fails Creates a new venv folder with the parameters provided at create time. \"\"\" # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e","title":"create"},{"location":"API/cnlib/cnvenv/#cnlib.cnvenv.CNVenv.freeze","text":"Freeze packages in the venv folder to the file_reqs property Parameters: Name Type Description Default file_reqs File to save requirements required Freezes current packages in the venv dir into a file for easy installation. Source code in cnlib/cnvenv.py def freeze(self, file_reqs): \"\"\" Freeze packages in the venv folder to the file_reqs property Args: file_reqs: File to save requirements Raises: cnlib.cnfunctions.CNRunError if the freeze fails Freezes current packages in the venv dir into a file for easy installation. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # the command to freeze a venv cmd = self.S_CMD_FREEZE.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True) except F.CNRunError as e: raise e","title":"freeze"},{"location":"API/cnlib/cnvenv/#cnlib.cnvenv.CNVenv.install_reqs","text":"Install packages to venv from the reqs_file property Parameters: Name Type Description Default file_reqs File to load requirements required This method takes requirements in the reqs_file property and installs them in the dir_venv property. Source code in cnlib/cnvenv.py def install_reqs(self, file_reqs): \"\"\" Install packages to venv from the reqs_file property Args: file_reqs: File to load requirements Raises: cnlib.cnfunctions.CNRunError if the reqs install fails This method takes requirements in the reqs_file property and installs them in the dir_venv property. \"\"\" # if param is not abs, make abs rel to prj dir file_reqs = Path(file_reqs) if not file_reqs.is_absolute(): file_reqs = self._dir_prj / file_reqs # ignore missing/empty files if not file_reqs.exists() or file_reqs.stat().st_size == 0: return # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, file_reqs ) try: F.run(cmd, shell=True, capture_output=True) except F.CNRunError as e: raise e","title":"install_reqs"}]}