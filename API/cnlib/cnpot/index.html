<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>cnpot.py - CNLib</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "cnpot.py";
        var mkdocs_page_input_path = "API/cnlib/cnpot.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> CNLib
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" >Cnlib</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../cnformatter/">cnformatter.py</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cnfunctions/">cnfunctions.py</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cninstall/">cninstall.py</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cnmkdocs/">cnmkdocs.py</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="#">cnpot.py</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#cnlib.cnpot">cnpot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cnlib.cnpot.CNPotPy">CNPotPy</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cnlib.cnpot.CNPotPy.__init__">__init__</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cnlib.cnpot.CNPotPy.main">main</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cnlib.cnpot.CNPotPy.make_desktop">make_desktop</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cntree/">cntree.py</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cnvenv/">cnvenv.py</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">CNLib</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">API</li>
          <li class="breadcrumb-item">Cnlib</li>
      <li class="breadcrumb-item active">cnpot.py</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="cnpotpy">cnpot.py</h1>


<div class="doc doc-object doc-module">



<a id="cnlib.cnpot"></a>
    <div class="doc doc-contents first">

        <p>Run GNU gettext tools to create i18n files for a project</p>
<p>This class converts all marked strings in source files to i18n versions using
xgettext, and creates .pot files in the locale directory. It also uses msgfmt
to convert .po files to .mo files.</p>
<p>The class can handle all xgettext's supported file types by using each language
name as the key for a list of file extensions in a dictionary.</p>
<p>Note that the word "language" here can refer either to the computer language of
the input file (ie. "Python", "Glade") or the written language of the output
file (ie. "English", "Spanish"). I have tried to disambiguate this by using
"clang(s)" to refer to the former, and "wlang(s)" to refer to the latter.</p>









  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="cnlib.cnpot.CNPotPy" class="doc doc-heading">
            <code>CNPotPy</code>


</h2>


    <div class="doc doc-contents ">


        <p>A class to handle making the different I18N files needed for a Python
project</p>


<p><span class="doc-section-title">Methods:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
            <tr class="doc-section-item">
              <td><code><a class="autorefs autorefs-internal" title="main() (cnlib.cnpot.CNPotPy.main)" href="#cnlib.cnpot.CNPotPy.main">main</a></code></td>
              <td>
                <div class="doc-md-description">
                  <p>Run the program and make or update the files</p>
                </div>
              </td>
            </tr>
            <tr class="doc-section-item">
              <td><code><a class="autorefs autorefs-internal" title="make_desktop(dt_template, dt_out) (cnlib.cnpot.CNPotPy.make_desktop)" href="#cnlib.cnpot.CNPotPy.make_desktop">make_desktop</a></code></td>
              <td>
                <div class="doc-md-description">
                  <p>Localize the desktop file using all available wlangs</p>
                </div>
              </td>
            </tr>
      </tbody>
    </table>
        <p>This class provides methods to create .pot, .po, .mo, and .desktop files
for internationalizing a Python or PyGObject project.</p>







              <details class="quote">
                <summary>Source code in <code>cnlib/cnpot.py</code></summary>
                <pre class="highlight"><code class="language-python">class CNPotPy:
    """
    A class to handle making the different I18N files needed for a Python
    project

    Methods:
        main: Run the program and make or update the files
        make_desktop: Localize the desktop file using all available wlangs

    This class provides methods to create .pot, .po, .mo, and .desktop files
    for internationalizing a Python or PyGObject project.
    """

    # --------------------------------------------------------------------------
    # Class constants
    # --------------------------------------------------------------------------

    # default encoding for .pot and .po files
    S_ENCODING = "UTF-8"
    # this is the default subdir for GNU
    S_DIR_LC = "LC_MESSAGES"
    # the file to store all wlang/domain names for .desktop files
    S_FILE_LINGUAS = "LINGUAS"

    # default file extensions
    S_EXT_POT = ".pot"
    S_EXT_PO = ".po"
    S_EXT_MO = ".mo"

    # shell commands to make po/mo
    # NB: format params are file_po and pot_file
    S_CMD_MERGE_POS = "msgmerge --update {} {} --backup=none"
    # NB: format params are mo_file and wlang_po
    S_CMD_MAKE_MOS = "msgfmt -o {} {}"
    # NB: format params are po dir, template file, and output file
    S_CMD_DESK = "msgfmt --desktop -d {} --template={} -o {} "

    # NB: format param is dir_prj
    S_ERR_NOT_ABS = "path {} is not absolute"
    # NB: format param is dir_prj
    S_ERR_NOT_DIR = "path {} is not a directory"

    # header regexes
    R_TITLE_SCH = r"# SOME DESCRIPTIVE TITLE."
    R_TITLE_REP = r"# {} translation template"

    R_COPY_SCH = (
        r"(# Copyright \(C\) )(YEAR)( )(THE PACKAGE'S COPYRIGHT HOLDER)"
    )
    R_COPY_REP = r"\g&lt;1&gt;{}\g&lt;3&gt;{}"

    R_EMAIL_SCH = r"(# FIRST AUTHOR )(&lt;EMAIL@ADDRESS&gt;)(, )(YEAR)"
    R_EMAIL_REP = r"\g&lt;1&gt;{}\g&lt;3&gt;{}"

    R_CHAR_SCH = r"(\"Content-Type: text/plain; charset=)(CHARSET)(.*)"
    R_CHAR_REP = r"\g&lt;1&gt;{}\g&lt;3&gt;"

    R_VER_SCH = r"^(\"Project-Id-Version: .*? )([^\n]*)(\\n\")$"
    R_VER_REP = r"\g&lt;1&gt;{}\g&lt;3&gt;"

    # --------------------------------------------------------------------------
    # Class methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Initialize the new object
    # --------------------------------------------------------------------------
    def __init__(
        self,
        # header
        str_domain,
        str_version,
        str_author,
        str_email,
        # base prj dir
        dir_prj,
        # in
        list_src,
        # out
        dir_pot,
        dir_po,
        dir_locale,
        # optional in
        str_tag=None,
        dict_clangs=None,
        list_wlangs=None,
        charset=S_ENCODING,
    ):
        """
        Initialize the new object

        Args:
            str_domain: The name of the domain (base name) for output files
                This creates files like "&lt;str_domain&gt;.pot", "&lt;str_domain&gt;.po",
                and "&lt;str_domain&gt;.mo", and is used in the .py scripts to bind a
                domain to a locale folder
            str_version: Version info to use in .pot/.po header
            str_author: Author name to use in .pot/.po header
            str_email: Email to use in .pot/.po header

            dir_prj: The main project dir, used for relative paths

            list_src: Where to look for input files

            dir_pot: Directory to place master .pot file
            dir_po: Directory to place .po file
            dir_locale: Directory to place .mo files

            str_tag: Tag that starts a context comment (default: None)
                If this string is empty or None, all comments above an entry
                are included as context.
            dict_clangs: The dictionary of file extensions to scan for each
            clang (default: None)
                If ths dict is empty or None, all files will be scanned
                (this is generally considered a "Very Bad Thing").
            list_wlangs: A list of supported languages to ensure a complete
            file structure in the project dir (default: None)
            charset: the charset to use as the default in the .pot file, and
            any initial .po files created (default: "UTF-8")

        An example format for the dict_clangs arg is:

        {
            "Python": [
                ".py",
            ],
            "Glade": [
                ".ui",
                ".glade",
            ],
            "Desktop": [
                ".desktop"
            ],
        }

        An example format for list_wlangs is:
        [
            "en_US",
            "de_DE.ISO_88591",
            "es",
        ]

        Initializes a new instance of the class, setting the default values of
        its properties, and any other code needed to create a new object.
        """

        # set header info
        self._str_domain = str_domain
        self._str_version = str_version
        self._str_author = str_author
        self._str_email = str_email

        # set base props
        self._dir_prj = Path(dir_prj)

        # fix up in props
        if list_src is None:
            list_src = []
        self._list_src = list_src

        # set out props
        self._dir_pot = Path(dir_pot)
        if not self._dir_pot.is_absolute():
            self._dir_pot = self._dir_prj / dir_pot
        self._dir_po = Path(dir_po)
        if not self._dir_po.is_absolute():
            self._dir_po = self._dir_prj / dir_po
        self._dir_locale = Path(dir_locale)
        if not self._dir_locale.is_absolute():
            self._dir_locale = self._dir_prj / dir_locale

        # set optional in props

        # set comment tag
        if str_tag is None:
            str_tag = ""
        self._str_tag = str_tag

        # fix up dict_clangs
        if dict_clangs is None:
            dict_clangs = {}
        self._dict_clangs = dict(dict_clangs)

        # fix up list_wlangs
        if list_wlangs is None:
            list_wlangs = []
        self._list_wlangs = list(list_wlangs)

        # fix up charset
        if charset is None:
            charset = self.S_ENCODING
        self._charset = charset

    # --------------------------------------------------------------------------
    # Public methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Run the program and make or update the files
    # --------------------------------------------------------------------------
    def main(self):
        """
        Run the program and make or update the files

        Raises:
            cnlib.cnfunctions.CNRunError if anything fails

        Main method of the class, performing its steps. This method can (and
        should) be run, in Mayor Tweed's words, "early and often". You should
        run it every time a source file that contains i18n strings is added,
        edited, or deleted. The ideal scenario is to run it just before the
        repo is synced, so that the .pot file is synced.
        """

        # ----------------------------------------------------------------------
        # do the steps

        # make sure all necessary dirs exist
        self._make_wlang_dirs()

        try:
            self._make_pot()
            self._make_pos()
            self._make_mos()
        except F.CNRunError as e:
            raise e

    # --------------------------------------------------------------------------
    # Localize the desktop file using all available wlangs
    # --------------------------------------------------------------------------
    def make_desktop(self, dt_template, dt_out):
        """
        Localize the desktop file using all available wlangs

        Args:
            dt_template: File containing the default information to include in
            the desktop file
                This is the file that pymaker/pybaker modifies using metadata.
            dt_out: Location of the i18n'ed desktop file
                This is the file that will be distributed with your app.

        Raises:
            cnlib.cnfunctions.CNRunError if the make fails

        Takes a template desktop file and applies all i18n'ed info from all .po
        files in the po folder and creates a final .desktop file.
        """

        # fix params to abs paths
        dt_template = Path(dt_template)
        if not dt_template.is_absolute():
            dt_template = self._dir_prj / dt_template
        dt_out = Path(dt_out)
        if not dt_out.is_absolute():
            dt_out = self._dir_prj / dt_out

        # check if template exists
        if dt_template.exists():

            # build the command as a string
            cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out)

            # run the command
            try:
                F.run(cmd)
            except F.CNRunError as e:
                raise e

    # --------------------------------------------------------------------------
    # Private methods
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Create a .pot file in the locale folder
    # --------------------------------------------------------------------------
    def _make_pot(self):
        """
        Create a .pot file in the pot folder

        Raises:
            cnlib.cnfunctions.CNRunError if the make fails

        Parses the files for each clang, creating a unified .pot file, which is
        placed in "&lt;dir_pot&gt;/&lt;str_domain&gt;.pot".
        """

        # ok so this is a tricky situation. here are the possible scenarios:
        # 1. create a new, fresh .pot that has never existed before
        # 2. add / edit / remove files to / from a .pot file we have already
        #    created
        # 3. add / edit / remove strings to / from a .pot file we have already
        #    created
        # 4. add / edit / remove clang types to / from a .pot file we have
        #    already created
        # 6. etc., etc., etc
        # how do we do all this (at least in the context of a .pot file)?
        # the simplest answer would seem to be:
        # delete the .pot (if it exists) and start over fresh every time
        # BUT! we need to use the -j (join) flag in order to allow multiple
        # clangs to be combined into one .pot file
        # the solution i have found is:
        # delete the existing .pot file (if it exists)
        # create a new, empty .pot file (if it does not exist, which it
        # shouldn't, race conditions be damned... Python file operations are
        # atomic, right? RIGHT???)
        # run every clang through xgettext, joining it with the previous file
        # until we have a .pot file that contains every string (and only the
        # strings) in dict_clangs
        # step 3: PROFIT! (hahaha that joke never gets old...)

        # get path to pot file
        file_pot = self._dir_pot / f"{self._str_domain}{self.S_EXT_POT}"

        # delete the existing .pot file (if it exists)
        file_pot.unlink(missing_ok=True)

        # create a new, empty .pot file if it does not exist
        # NB: this allow us to use the -j flag without error (which would
        # happen if the current file to join does not exist)
        file_pot.parent.mkdir(parents=True, exist_ok=True)
        file_pot.touch(exist_ok=True)

        # get all paths for this domain
        # NB: or if no src list specified, scan ALL files
        clangs_paths = self._get_paths_for_clangs()

        # for each clang name / list of clang files
        for clang_name, clang_files in clangs_paths.items():

            # sanity check
            if len(clang_files) == 0:
                continue

            # get initial cmd
            cmd = (
                f"cd {self._dir_prj}; "
                "xgettext "
                # add any comments above string (or msgctxt in ui files)
                # NB: check that all files have appropriate contexts/comments
                # NB: also, no space after -c? weird right?
                f"-c{self._str_tag} "
                # fix some header values (the rest should be fixed in
                # _fix_pot_header)
                # copyright
                # NB: if blank, file is public domain
                # if not included, file is under same license as _str_appname
                # "--copyright-holder "" "
                # version
                # | name | version | Project-Id-Version
                # -----------------------------------
                # |    0 |       0 | PACKAGE VERSION
                # |    0 |       1 | PACKAGE VERSION
                # |    1 |       0 | self._str_domain
                # |    1 |       1 | self._str_domain self._str_version
                f"--package-name {self._str_domain} "
                f"--package-version {self._str_version} "
                # author email
                f"--msgid-bugs-address {self._str_email} "
                # sort entries by file
                "-F "
                # don't add location info (hide path to source)
                # "--no-location "
                # append existing file
                # NB: this is the key to running xgettext multiple times for
                # one domain
                # this allows us to set the -L option for different file types
                # and still end up with one unified .pot file
                "-j "
                # final name of output file
                # NB: note that you can fiddle with the -o, -d, and -p options
                # here, but i find it's just better to use an abs path to the
                # output file
                f"-o {file_pot} "
                # add -L for specific exts
                f"-L {clang_name} "
            )

            # add all input files
            paths = [f'"{item}" ' for item in clang_files]
            j_paths = "".join(paths)
            cmd += j_paths

            # do the final command
            try:
                F.run(cmd, shell=True)
            except F.CNRunError as e:
                raise e

            # fix CHARSET in pot
            self._fix_pot_header(file_pot)

    # --------------------------------------------------------------------------
    # Merge any .po files in the pos folder with existing .po files
    # --------------------------------------------------------------------------
    def _make_pos(self):
        """
        Create .po files in the po folder or merge any updated .pot files with
        existing .po files

        Raises:
            cnlib.cnfunctions.CNRunError if the make fails

        Whenever a new .pot file is generated using make_pot, this method will
        produce a new .po file for each wlang that contains the difference
        between the new .pot file and the existing .po file.

        This new .po file should be sent to the translator for each wlang. Then
        when the translator sends back the translated .po file, place it in the
        appropriate &lt;dir_po&gt;/&lt;wlang&gt; dir. Then run pybaker to create a new .mo
        file.
        """

        # for each wlang in the po folder
        for wlang in self._list_wlangs:

            # get the pot file we made in the last step
            file_pot = self._dir_pot / f"{self._str_domain}{self.S_EXT_POT}"

            # create or update the .po file
            file_po = (
                self._dir_po / f"{wlang}/{self._str_domain}{self.S_EXT_PO}"
            )
            file_po.parent.mkdir(parents=True, exist_ok=True)
            if not file_po.exists():

                # no po file, copy pot
                shutil.copy(file_pot, file_po)
                continue

            # update existing po file using latest pot
            cmd = self.S_CMD_MERGE_POS.format(file_po, file_pot)
            try:
                F.run(cmd)
            except F.CNRunError as e:
                raise e

    # --------------------------------------------------------------------------
    # Create .mo files for all .po files in the locale folder
    # --------------------------------------------------------------------------
    def _make_mos(self):
        """
        Create .mo files for all .po files in the locale folder

        Raises:
            cnlib.cnfunctions.CNRunError if the make fails

        Makes all the required .mo files for all the .po files in the locale
        dir
        """

        # get all wlangs to output
        glob_po = f"**/*{self.S_EXT_PO}"
        list_pos = list(self._dir_po.glob(glob_po))

        # for each wlang
        for file_po in list_pos:

            # get wlang name
            wlang = file_po.parent.name  # en, etc

            # get .mo file (output)
            mo_dir = self._dir_locale / wlang / self.S_DIR_LC
            mo_dir.mkdir(parents=True, exist_ok=True)
            mo_file = mo_dir / f"{self._str_domain}{self.S_EXT_MO}"

            # do the command
            cmd = self.S_CMD_MAKE_MOS.format(mo_file, file_po)
            try:
                F.run(cmd)
            except F.CNRunError as e:
                raise e

    # --------------------------------------------------------------------------
    # Make a list of all supported written language directories
    # --------------------------------------------------------------------------
    def _make_wlang_dirs(self):
        """
        Make a list of all supported written language directories

        This writes the LINGUAS file, which is used for i18n'ing a .desktop
        file.
        """

        # ----------------------------------------------------------------------

        # make the main dirs
        self._dir_pot.mkdir(parents=True, exist_ok=True)
        self._dir_po.mkdir(parents=True, exist_ok=True)
        self._dir_locale.mkdir(parents=True, exist_ok=True)

        # make the LC dirs
        for wlang in self._list_wlangs:

            # make the locale/lang/LC_MESSAGES dir
            mo_dir = self._dir_locale / wlang / self.S_DIR_LC
            mo_dir.mkdir(parents=True, exist_ok=True)

        # make LINGUAS file
        linguas = ""
        for wlang in self._list_wlangs:
            # add each wlang to LINGUAS file
            linguas += f"{wlang}/{self._str_domain} "

        # write the LINGUAS file
        linguas_path = self._dir_po / self.S_FILE_LINGUAS
        with open(linguas_path, "w", encoding=self.S_ENCODING) as f:
            f.write(linguas)

    # --------------------------------------------------------------------------
    # Scan the source dirs for files with certain extensions
    # --------------------------------------------------------------------------
    def _get_paths_for_clangs(self):
        """
        Scan the source dirs for files with certain extensions

        Returns:
            A dictionary containing file paths to source files

        This method uses the list_src list to convert the dict_clangs
        dictionary:
            {
                "Python": [".py"],
                "Glade": [".ui", ".glade"],
                "Desktop": [".desktop"],
            }
        into a dictionary of file paths to scan for each clang:
            {
                "Python": [&lt;str&gt;, ...],
                "Glade": [&lt;str&gt;, ...],
                "Desktop": [&lt;str&gt;, ...],
            }
        so they can be passed to xgettext.
        """

        # the dict to return
        dict_res = {}

        # ----------------------------------------------------------------------

        # for each item in list_src
        for place in self._list_src:

            # resolve place
            p_place = self._dir_prj / place

            # check if dir
            if p_place.is_dir():

                # for each clang name / list of exts
                for clang, exts in self._dict_clangs.items():

                    # the new list of files
                    list_clang = []

                    # for each clang ext
                    for ext in exts:

                        # get matching files and add to list
                        res = list(
                            p_place.glob("**/*" + ext, case_sensitive=False)
                        )
                        list_clang.extend(res)

                    # update result lang's val
                    # NB: xgettext does not handle Paths, only strs
                    list_clang = [str(item) for item in list_clang]
                    list_old = dict_res.get(clang, [])
                    list_old.extend(list_clang)
                    dict_res[clang] = list_old

            # src item is file
            else:

                # get item suffix (including dot)
                ext_place = p_place.suffix

                # find lang from suffix
                for clang, exts in self._dict_clangs.items():  # Python, [".py"]

                    # if this item belongs to this clang
                    if ext_place in exts:

                        # update result lang's val
                        # NB: xgettext does not handle Paths, only strs
                        list_old = dict_res.get(clang, [])
                        list_old.extend([str(p_place)])
                        dict_res[clang] = list_old

                        break

        # ----------------------------------------------------------------------

        # return the result
        return dict_res

    # --------------------------------------------------------------------------
    # Set the header values for the pot which will carry over to each po
    # --------------------------------------------------------------------------
    def _fix_pot_header(self, file_pot):
        """
        Set the header values for the pot which will carry over to each po

        Args:
            file_pot: the path object representing the pot file to fix

        Fix the charset in the pot file to a known value so that msgfmt does
        not complain. The charset for an individual file can be set by the
        translator. This is just to keep the compiler from complaining, and
        also aids in testing when no editing is done.
        """

        # open file and get contents
        with open(file_pot, "r", encoding=self.S_ENCODING) as a_file:
            text = a_file.read()

        # replace short description
        str_pattern = self.R_TITLE_SCH
        str_rep = self.R_TITLE_REP.format(self._str_domain)
        text = re.sub(str_pattern, str_rep, text)

        # replace copyright
        str_pattern = self.R_COPY_SCH
        year = date.today().year
        str_rep = self.R_COPY_REP.format(year, self._str_author)
        text = re.sub(str_pattern, str_rep, text)

        # replace author's email
        str_pattern = self.R_EMAIL_SCH
        email = self._str_email
        year = date.today().year
        str_rep = self.R_EMAIL_REP.format(email, year)
        text = re.sub(str_pattern, str_rep, text)

        # NB: if the specific phrase "CHARSET" is not found, nothing will be
        # changed
        str_pattern = self.R_CHAR_SCH
        str_rep = self.R_CHAR_REP.format(self._charset)
        text = re.sub(str_pattern, str_rep, text, flags=re.M)

        # save file
        with open(file_pot, "w", encoding=self.S_ENCODING) as a_file:
            a_file.write(text)</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="cnlib.cnpot.CNPotPy.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(str_domain, str_version, str_author, str_email, dir_prj, list_src, dir_pot, dir_po, dir_locale, str_tag=None, dict_clangs=None, list_wlangs=None, charset=S_ENCODING)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize the new object</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>str_domain</code></b>
              –
              <div class="doc-md-description">
                <p>The name of the domain (base name) for output files
This creates files like "<str_domain>.pot", "<str_domain>.po",
and "<str_domain>.mo", and is used in the .py scripts to bind a
domain to a locale folder</p>
              </div>
            </li>
            <li>
              <b><code>str_version</code></b>
              –
              <div class="doc-md-description">
                <p>Version info to use in .pot/.po header</p>
              </div>
            </li>
            <li>
              <b><code>str_author</code></b>
              –
              <div class="doc-md-description">
                <p>Author name to use in .pot/.po header</p>
              </div>
            </li>
            <li>
              <b><code>str_email</code></b>
              –
              <div class="doc-md-description">
                <p>Email to use in .pot/.po header</p>
              </div>
            </li>
            <li>
              <b><code>dir_prj</code></b>
              –
              <div class="doc-md-description">
                <p>The main project dir, used for relative paths</p>
              </div>
            </li>
            <li>
              <b><code>list_src</code></b>
              –
              <div class="doc-md-description">
                <p>Where to look for input files</p>
              </div>
            </li>
            <li>
              <b><code>dir_pot</code></b>
              –
              <div class="doc-md-description">
                <p>Directory to place master .pot file</p>
              </div>
            </li>
            <li>
              <b><code>dir_po</code></b>
              –
              <div class="doc-md-description">
                <p>Directory to place .po file</p>
              </div>
            </li>
            <li>
              <b><code>dir_locale</code></b>
              –
              <div class="doc-md-description">
                <p>Directory to place .mo files</p>
              </div>
            </li>
            <li>
              <b><code>str_tag</code></b>
              –
              <div class="doc-md-description">
                <p>Tag that starts a context comment (default: None)
If this string is empty or None, all comments above an entry
are included as context.</p>
              </div>
            </li>
            <li>
              <b><code>dict_clangs</code></b>
              –
              <div class="doc-md-description">
                <p>The dictionary of file extensions to scan for each</p>
              </div>
            </li>
            <li>
              <b><code>clang</code></b>
                  (<code><span title="default">default</span></code>)
              –
              <div class="doc-md-description">
                <p>None)
If ths dict is empty or None, all files will be scanned
(this is generally considered a "Very Bad Thing").</p>
              </div>
            </li>
            <li>
              <b><code>list_wlangs</code></b>
              –
              <div class="doc-md-description">
                <p>A list of supported languages to ensure a complete</p>
              </div>
            </li>
            <li>
              <b><code>file</code></b>
                  (<code>structure in the project dir (default</code>)
              –
              <div class="doc-md-description">
                <p>None)</p>
              </div>
            </li>
            <li>
              <b><code>charset</code></b>
              –
              <div class="doc-md-description">
                <p>the charset to use as the default in the .pot file, and</p>
              </div>
            </li>
            <li>
              <b><code>any</code></b>
                  (<code>initial .po files created (default</code>)
              –
              <div class="doc-md-description">
                <p>"UTF-8")</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>An example format for the dict_clangs arg is:</p>
<p>{
    "Python": [
        ".py",
    ],
    "Glade": [
        ".ui",
        ".glade",
    ],
    "Desktop": [
        ".desktop"
    ],
}</p>
<p>An example format for list_wlangs is:
[
    "en_US",
    "de_DE.ISO_88591",
    "es",
]</p>
<p>Initializes a new instance of the class, setting the default values of
its properties, and any other code needed to create a new object.</p>


            <details class="quote">
              <summary>Source code in <code>cnlib/cnpot.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(
    self,
    # header
    str_domain,
    str_version,
    str_author,
    str_email,
    # base prj dir
    dir_prj,
    # in
    list_src,
    # out
    dir_pot,
    dir_po,
    dir_locale,
    # optional in
    str_tag=None,
    dict_clangs=None,
    list_wlangs=None,
    charset=S_ENCODING,
):
    """
    Initialize the new object

    Args:
        str_domain: The name of the domain (base name) for output files
            This creates files like "&lt;str_domain&gt;.pot", "&lt;str_domain&gt;.po",
            and "&lt;str_domain&gt;.mo", and is used in the .py scripts to bind a
            domain to a locale folder
        str_version: Version info to use in .pot/.po header
        str_author: Author name to use in .pot/.po header
        str_email: Email to use in .pot/.po header

        dir_prj: The main project dir, used for relative paths

        list_src: Where to look for input files

        dir_pot: Directory to place master .pot file
        dir_po: Directory to place .po file
        dir_locale: Directory to place .mo files

        str_tag: Tag that starts a context comment (default: None)
            If this string is empty or None, all comments above an entry
            are included as context.
        dict_clangs: The dictionary of file extensions to scan for each
        clang (default: None)
            If ths dict is empty or None, all files will be scanned
            (this is generally considered a "Very Bad Thing").
        list_wlangs: A list of supported languages to ensure a complete
        file structure in the project dir (default: None)
        charset: the charset to use as the default in the .pot file, and
        any initial .po files created (default: "UTF-8")

    An example format for the dict_clangs arg is:

    {
        "Python": [
            ".py",
        ],
        "Glade": [
            ".ui",
            ".glade",
        ],
        "Desktop": [
            ".desktop"
        ],
    }

    An example format for list_wlangs is:
    [
        "en_US",
        "de_DE.ISO_88591",
        "es",
    ]

    Initializes a new instance of the class, setting the default values of
    its properties, and any other code needed to create a new object.
    """

    # set header info
    self._str_domain = str_domain
    self._str_version = str_version
    self._str_author = str_author
    self._str_email = str_email

    # set base props
    self._dir_prj = Path(dir_prj)

    # fix up in props
    if list_src is None:
        list_src = []
    self._list_src = list_src

    # set out props
    self._dir_pot = Path(dir_pot)
    if not self._dir_pot.is_absolute():
        self._dir_pot = self._dir_prj / dir_pot
    self._dir_po = Path(dir_po)
    if not self._dir_po.is_absolute():
        self._dir_po = self._dir_prj / dir_po
    self._dir_locale = Path(dir_locale)
    if not self._dir_locale.is_absolute():
        self._dir_locale = self._dir_prj / dir_locale

    # set optional in props

    # set comment tag
    if str_tag is None:
        str_tag = ""
    self._str_tag = str_tag

    # fix up dict_clangs
    if dict_clangs is None:
        dict_clangs = {}
    self._dict_clangs = dict(dict_clangs)

    # fix up list_wlangs
    if list_wlangs is None:
        list_wlangs = []
    self._list_wlangs = list(list_wlangs)

    # fix up charset
    if charset is None:
        charset = self.S_ENCODING
    self._charset = charset</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cnlib.cnpot.CNPotPy.main" class="doc doc-heading">
            <code class="highlight language-python">main()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Run the program and make or update the files</p>
        <p>Main method of the class, performing its steps. This method can (and
should) be run, in Mayor Tweed's words, "early and often". You should
run it every time a source file that contains i18n strings is added,
edited, or deleted. The ideal scenario is to run it just before the
repo is synced, so that the .pot file is synced.</p>


            <details class="quote">
              <summary>Source code in <code>cnlib/cnpot.py</code></summary>
              <pre class="highlight"><code class="language-python">def main(self):
    """
    Run the program and make or update the files

    Raises:
        cnlib.cnfunctions.CNRunError if anything fails

    Main method of the class, performing its steps. This method can (and
    should) be run, in Mayor Tweed's words, "early and often". You should
    run it every time a source file that contains i18n strings is added,
    edited, or deleted. The ideal scenario is to run it just before the
    repo is synced, so that the .pot file is synced.
    """

    # ----------------------------------------------------------------------
    # do the steps

    # make sure all necessary dirs exist
    self._make_wlang_dirs()

    try:
        self._make_pot()
        self._make_pos()
        self._make_mos()
    except F.CNRunError as e:
        raise e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cnlib.cnpot.CNPotPy.make_desktop" class="doc doc-heading">
            <code class="highlight language-python">make_desktop(dt_template, dt_out)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Localize the desktop file using all available wlangs</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>dt_template</code></b>
              –
              <div class="doc-md-description">
                <p>File containing the default information to include in</p>
              </div>
            </li>
            <li>
              <b><code>dt_out</code></b>
              –
              <div class="doc-md-description">
                <p>Location of the i18n'ed desktop file
This is the file that will be distributed with your app.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Takes a template desktop file and applies all i18n'ed info from all .po
files in the po folder and creates a final .desktop file.</p>


            <details class="quote">
              <summary>Source code in <code>cnlib/cnpot.py</code></summary>
              <pre class="highlight"><code class="language-python">def make_desktop(self, dt_template, dt_out):
    """
    Localize the desktop file using all available wlangs

    Args:
        dt_template: File containing the default information to include in
        the desktop file
            This is the file that pymaker/pybaker modifies using metadata.
        dt_out: Location of the i18n'ed desktop file
            This is the file that will be distributed with your app.

    Raises:
        cnlib.cnfunctions.CNRunError if the make fails

    Takes a template desktop file and applies all i18n'ed info from all .po
    files in the po folder and creates a final .desktop file.
    """

    # fix params to abs paths
    dt_template = Path(dt_template)
    if not dt_template.is_absolute():
        dt_template = self._dir_prj / dt_template
    dt_out = Path(dt_out)
    if not dt_out.is_absolute():
        dt_out = self._dir_prj / dt_out

    # check if template exists
    if dt_template.exists():

        # build the command as a string
        cmd = self.S_CMD_DESK.format(self._dir_po, dt_template, dt_out)

        # run the command
        try:
            F.run(cmd)
        except F.CNRunError as e:
            raise e</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../cnmkdocs/" class="btn btn-neutral float-left" title="cnmkdocs.py"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../cntree/" class="btn btn-neutral float-right" title="cntree.py">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../cnmkdocs/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../cntree/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
